<!doctype html public "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<html>
<head>
<title>
js-xmlrpc Overview
</title>
<link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script>
function asd() {
	
		parent.document.title="xmlrpc_lib.js Overview";
	
}
</script>
</head>
<body bgcolor="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> 	<font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top">
<em>
<b>js-xmlrpc</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<center>
	
	   <h2>xmlrpc_lib.js</h2>
	
</center>

	


<h4>Summary</h4>
<p>
	
		No overview generated for 'xmlrpc_lib.js'<BR/><BR/>
	
</p>

<hr>


    <table border="1" cellpadding="3" cellspacing="0" width="100%">
    <tr bgcolor="#CCCCFF" class="TableHeadingColor">
    <td colspan=2><font size="+2">
    
        <b>Class Summary</b>
    
    </font></td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="xmlrpc_client.html">xmlrpc_client</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="xmlrpcmsg.html">xmlrpcmsg</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="xmlrpcresp.html">xmlrpcresp</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="xmlrpcval.html">xmlrpcval</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    </table>
    <hr/> 


<!-- ========== METHOD SUMMARY =========== -->

	<a name="method_summary"><!-- --></a>
	<table border="1" cellpadding="3" cellspacing="0" width="100%">
		<tr bgcolor="#CCCCFF" class="TableHeadingColor">
			<td colspan=2>
				<font size="+2">
					<b>Method Summary</b>
				</font>
			</td>
		</tr>
	
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;string</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!base64_decode">base64_decode</a></b>(&lt;string&gt; aString)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Decodes a Base64 encoded string to a byte string.
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;string</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!base64_encode">base64_encode</a></b>(&lt;string&gt; aString)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Encodes a string using Base64.
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;string</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!htmlentities">htmlentities</a></b>(&lt;string&gt; val, quote_style)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Debug helper.
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;<a href="Date.html">Date</a></code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!iso8601_decode">iso8601_decode</a></b>(&lt;string&gt; time, &lt;boolean&gt; utc)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Given an ISO8601 date string, return a date obj in the localtime, or UTC
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;string</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!iso8601_encode">iso8601_encode</a></b>(&lt;<a href="Date.html">Date</a>&gt; time, &lt;boolean&gt; utc)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Given a Date object, returns its representation in the iso8601 format used by xmlrpc
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;string</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!var_export">var_export</a></b>(&lt;mixed&gt; val, &lt;boolean&gt; ret, &lt;boolean&gt; whitespaces)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Debug helper.
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;void</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!xmlrpc_debug_log">xmlrpc_debug_log</a></b>(&lt;string&gt; logmsg)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Function used to send a debug message to the log.
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;mixed</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!xmlrpc_decode">xmlrpc_decode</a></b>(&lt;<a href="xmlrpcval.html">xmlrpcval</a>&gt; xmlrpc_val, options)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Takes an xmlrpc value in xmlrpcval object format and translates it into native javascript types.
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;mixed</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!xmlrpc_decode_xml">xmlrpc_decode_xml</a></b>(&lt;string&gt; xml_val, &lt;array&gt; options)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 !!!
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;<a href="xmlrpcval.html">xmlrpcval</a></code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!xmlrpc_encode">xmlrpc_encode</a></b>(&lt;mixed&gt; js_val, &lt;array&gt; options)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Takes native javascript types and encodes them recursively into xmlrpcval object format.
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;void</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!xmlrpc_error_log">xmlrpc_error_log</a></b>(errormsg)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Function used to send an error message to the log.
		      </td>
		   </tr>
		
	
	</table>
    <p>

<!-- ========== END METHOD SUMMARY =========== -->


        <pre class="sourceview"><span class="comment">/**
* JS-XMLRPC: Yet Another XMLRPC Library, in Javascript!
*
* ...as if the world needed it...
*
* FOR COMPLETE API DOCS, READ PHP-XMLRPC API DOCS. THE SAME API (almost) IS IMPLEMENTED HERE!
*
* Many thanks to Jan-Klaas Kollhof for JSOLAIT, and to the Yahoo YUI team, for
* providing the building blocks for all of this
*
* <span class="attrib">@version</span> $Id: xmlrpc_lib.js,v 1.24 2007/06/25 20:59:49 ggiunta Exp $
* <span class="attrib">@author</span> Gaetano Giunta
* <span class="attrib">@copyright</span> (c) 2006, 2007 G. Giunta
* <span class="attrib">@license</span> code licensed under the BSD License: http://phpxmlrpc.sourceforge.net/jsxmlrpc/license.txt
*
* KNOWN DIFFERENCES FROM PHP-XMLRPC:
* + internal struct of xmlrpcval is slightly different
* + xmlrpcresp.serialize() produces complete xml chunk, including xml prologue
* + adding data to a struct val using colliding keys might produce different results
* + xmlrpcresp has no private member 'content-type'
* + values of global object 'xmlrpcTypes' differ (keys are the same)
* + xmlrpcval::addScalar() does not coerce values when declaring them as boolean
* + xmlrpcmsg::parseResponse() can take a string as second parameter (full response headers)
* + objects have an init() constructor method (needed for subclassing)
* + client by default has keepalive ON, uses HTTP 1.1 (if browser set to use HTTP 1.1)
* + client by default will send to server any cookie received
* + client does not support ssl certs, proxies, ntlm auth (?)
* + client by default will support receiving compresssed content, many charsets, as per browser capabilities and settings
* + client supports making async calls. send() timeouts are ignored in sync calls
* + lib output is performed by two functions: xmlrpc_error_log and xmlrpc_debug_log
* + method names ARE KEY SENSISTIVE IN JAVASCRIPT, and this lib respects camelCase convention
*
* MISSING FEATURES:
* - xmlrpc_decode_xml
* - handling of charset encoding (where explicitly requested)
* - compression of requests
* - handling of compression, chunked encoding in parseResponseHeaders
* - JSLint, testsuite, speed tests, demo files
* - htmlentities only encodes as much as php function htmlspecialchars
* - encoding/decoding of anon js classes via an xml attribute (since it is hard to recover a class name, we could encode instead all methods code)
* - complete parsing of: new xmlrpcclient('http://james:bond<span class="attrib">@a</span>.complete/uri')
* - using client credentials for https auth
*
* IMPROVEMENTS:
* <span class="attrib">@todo</span> do not add methods to js base objects for serialization (use instanceof instead?)
* <span class="attrib">@todo</span> optimize generation of strings using array and join('') instead of strings and + (nb: in Opera it's slower, in IE faster...)
* <span class="attrib">@todo</span> add charset support to xmlrpc_encode_entities
*
* <span class="attrib">@todo</span> when creating date xmlrpc values, save date objects instead of strings?
* <span class="attrib">@todo</span> more in general, is it a good idea to save native js types inside xmlrpcvals
*       instead of native js objects? test memory/speed differences
* <span class="attrib">@todo</span> when decoding xmlrpc int and double vals, check if we can skip regexp validation and be faster
* <span class="attrib">@todo</span> fix base64_encode of empty strings (now it returns '0' on all browsers but FF)
*/</span>

<span class="comment">/******************************************************************************/</span>
<span class="comment">// global variables</span>

var xmlrpcI4 = <span class="literal">'i4'</span>;
var xmlrpcInt = <span class="literal">'int'</span>;
var xmlrpcBoolean = <span class="literal">'boolean'</span>;
var xmlrpcDouble = <span class="literal">'double'</span>;
var xmlrpcString = <span class="literal">'string'</span>;
var xmlrpcDateTime = <span class="literal">'dateTime.iso8601'</span>;
var xmlrpcBase64 = <span class="literal">'base64'</span>;
var xmlrpcArray = <span class="literal">'array'</span>;
var xmlrpcStruct = <span class="literal">'struct'</span>;
var xmlrpcValue = <span class="literal">'undefined'</span>;
var xmlrpcNull = <span class="literal">'null'</span>;

<span class="comment">/**
* <span class="attrib">@final</span>
*/</span>
var xmlrpcTypes = {
	xmlrpcI4 : 4,
	xmlrpcInt: 4,
	xmlrpcBoolean: 6,
	xmlrpcString: 1,
	xmlrpcDouble: 5,
	xmlrpcDateTime: 7,
	xmlrpcBase64: 8,
	xmlrpcArray: 2,
	xmlrpcStruct: 3,
	xmlrpcNull: 9
}

<span class="comment">/**
* Library name. Used in the client's httprequests to identify self to server
* <span class="attrib">@type</span> string
*/</span>
var xmlrpcName = <span class="literal">'XML-RPC for JAVASCRIPT'</span>;
<span class="comment">/**
* Library version number. Used in the client's httprequests to identify self to server
* <span class="attrib">@type</span> string
*/</span>
var xmlrpcVersion = <span class="literal">'0.3'</span>;

<span class="comment">// let user errors start at 800</span>
var xmlrpcerruser = 800;
<span class="comment">// let XML parse errors start at 100</span>
var xmlrpcerrxml = 100;

var xmlrpcerr = {
	invalid_return: 2,
	http_error: 5,
	no_data: 6,
	no_curl: 16,
	multicall_error: 18,
	no_parser: 19
}

var xmlrpcstr = {
	invalid_return: <span class="literal">'Invalid return payload: enable debugging to examine incoming payload'</span>,
	http_error: <span class="literal">'Didn\'</span>t receive 200 OK from remote server.<span class="literal">',
	no_data: '</span>No data received from server.<span class="literal">',
	no_curl: '</span>no support <span class="reserved">for</span> executing http requests compiled in<span class="literal">',
	multicall_error: '</span>Received from server invalid multicall response<span class="literal">',
	no_parser: '</span>no support <span class="reserved">for</span> parsing xml compiled in<span class="literal">'
}

var _xh = null;

// Please note that MS says you should only use versions 6 and 3...
// http://blogs.msdn.com/xmlteam/archive/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer.aspx
var _msxml_progid = ['</span>MSXML2.XMLHTTP.6.0<span class="literal">', '</span>MSXML2.XMLHTTP.3.0<span class="literal">', '</span>MSXML2.XMLHTTP.4.0<span class="literal">', '</span>MSXML2.XMLHTTP<span class="literal">','</span>Microsoft.XMLHTTP<span class="literal">'];
var _msxmldoc_progid = ['</span>MSXML2.DOMDOCUMENT.6.0<span class="literal">', '</span>MSXML2.DOMDOCUMENT.3.0<span class="literal">', '</span>MSXML2.DOMDOCUMENT.4.0<span class="literal">', '</span>MSXML2.DOMDOCUMENT<span class="literal">','</span>Microsoft.XMLDOM<span class="literal">'];

/******************************************************************************/
/**
* @param {string} path
* @param {string} server
* @param {integer} port optional. Defaults to 80 for http, 443 for https
* @param {string} method not in use yet. Valid values: '</span>https<span class="literal">', '</span>http<span class="literal">'
* @constructor
* @todo verify support for:
		https,
		proxies,
		auth types,
		recovering cookies, ---&gt; via getAllResponseHeaders()
		response/request compression, ---&gt; response = transparent by the browser, request === to do
		charset transcoding, ---&gt; done transparently (?) by the browser
		...
*/
function xmlrpc_client (path, server, port, method)
{
	/** @private **/
	this.path = '</span><span class="literal">';
	/** @private **/
	this.server = '</span><span class="literal">';
	/** @private **/
	this.port = 0; // verify if it can be used...
	/** @private **/
	this.method = '</span>http<span class="literal">';
	//this.errno = 0;
	//this.errstr = '</span><span class="literal">';
	/** @private **/
	this.debug = 0;
	/** @private **/
	this.username = '</span><span class="literal">';
	/** @private **/
	this.password = '</span><span class="literal">';
	this.no_multicall = false;
	/** @private **/
	this.cookies = {};
	this.return_type = '</span>xmlrpcvals<span class="literal">';
	this.keepalive = true;
	this.accepted_charset_encodings = '</span>auto<span class="literal">';
	/** @private **/
	this.accepted_compression = '</span>auto<span class="literal">';
	/** @private **/
	this.polling_interval = 50;
	this.polling_queue = [];
	this.tid = 0;

	this.init(path, server, port, method);
}

/**
* @todo correctly split url into components if given as single parameter
* @private
*/
xmlrpc_client.prototype.init = function (path, server, port, method)
{
	if (method === undefined &amp;&amp; port === undefined &amp;&amp; server === undefined)
	{
		if (path !== undefined &amp;&amp; path.search(/^https?:\/\/[^\/:]/) != -1)
		{
			/// @todo split eventual '</span>user:pwd@<span class="literal">' from server
			// NB: if server/port are different from window.location, this might not make much sense...
			var matches = path.match(/(https?):\/\/([^\/:]+)(:\d+)?(.+)?/);
			method = matches[1];
			server = matches[2];
			port = matches[3] == undefined ? matches[3] : matches[3].substr(1);
			path = matches[4] !== undefined ? matches[4] : '</span><span class="literal">';
		}
		else
		{
			if (path === undefined)
			{
				path = window.location.pathname + window.location.search;
			}
			// path is ok, server, port and method are taken from window.location
			server = window.location.hostname;
			port = window.location.port;
			method = window.location.protocol == '</span>https:<span class="literal">' ? '</span>https<span class="literal">' : '</span>http<span class="literal">';
		}
	}
	if (path == '</span><span class="literal">' || path.substr(0, 1) != '</span>/<span class="literal">')
	{
		this.path = '</span>/<span class="literal">' + path;
	}
	else
	{
		this.path = path;
	}
	this.server = server;
	if (port != undefined &amp;&amp; port != '</span><span class="literal">')
	{
		this.port = port;
	}
	if (method != undefined)
	{
		this.method = method;
	}
}

/**
* Enables/disables the echoing to screen of the xmlrpc responses received
* @param {integer} dbg values 0, 1 and 2 are supported (2 = echo sent msg too, before received response)
* @public
*/
xmlrpc_client.prototype.setDebug = function (dbg)
{
	this.debug = dbg;
}

/**
* Enables/disables reception of compressed xmlrpc responses.
* Note that enabling reception of compressed responses merely adds some standard
* http headers to xmlrpc requests. It is up to the xmlrpc server to return
* compressed responses when receiving such requests.
* @param {string} compmethod either '</span>gzip<span class="literal">', '</span>deflate<span class="literal">', '</span>any<span class="literal">', '</span>auto<span class="literal">' or '</span><span class="literal">'. '</span>auto<span class="literal">' means the javascript host (eg. the browser) will decide what to do
* @public
* @bug on IE setting does not seem to have any effect?
*/
xmlrpc_client.prototype.setAcceptedCompression = function (compmethod)
{
	if (compmethod == '</span>auto<span class="literal">')
		this.accepted_compression = compmethod;
	else if (compmethod == '</span>any<span class="literal">')
		this.accepted_compression = ['</span>gzip<span class="literal">', '</span>deflate<span class="literal">'];
	else
		this.accepted_compression = array[compmethod];
}

/**
* Add some http BASIC AUTH credentials, used by the client to authenticate
* @param {string} username
* @param {string} password
* @param {integer} authtype Not in use (yet). See curl_setopt man page for supported auth types. Defaults to CURLAUTH_BASIC (basic auth)
* @public
*/
xmlrpc_client.prototype.setCredentials = function (username, password, authtype)
{
	this.username = username;
	this.password = password;
	// authtype not yet supported...
	//if (authtype === undefined) {
	//	this.authtype = 1;
	//}
	//else {
	//	this.authtype = authtype;
	//}
}

/**
* Send an xmlrpc request.
*
* @param {mixed} msg The message object, or an array of messages for using multicall, or the complete xml representation of a request
* @param {integer} timeout Connection timeout, in seconds. If unspecified, or 0 a platform specific timeout will apply. Used only with async calls and callback faunctions.
* @param {string|object} if string: '</span>method<span class="literal">' - if left unspecified, the http protocol chosen during creation of the object will be used
*                        if object: callback function that accepts an xmlrpcresp obj as parameter
* @type xmlrpcresp
* @public
*/
xmlrpc_client.prototype.send = function (msg, timeout, method)
{
	var async = false;
	if (method === undefined || method === '</span><span class="literal">') {
		method = this.method;
	}
	else if (typeof(method) == '</span><span class="reserved">function</span><span class="literal">')
	{
		async = method;
		method = this.method;
	}


	if (this.port == 0)
	{
		if (window.location.port == '</span><span class="literal">')
		{
			// workaround for Safari BUG: if no port is given in current URL, it
			// will deny xhr access to url:80...
			var port = '</span><span class="literal">';
		}
		else
		{
			var port = '</span>:80<span class="literal">';
		}
	}
	else
	{
		var port = '</span>:<span class="literal">' + this.port;
	}
	if (typeof(msg) == '</span>object<span class="literal">' &amp;&amp; msg instanceof Array) {
		return this.multiCall(msg, timeout, method);
	} else if (typeof(msg) == '</span>string<span class="literal">') {
		var n = new xmlrpcmsg('</span><span class="literal">');
		n.payload = msg;
		msg = n;
	}
	msg.debug = this.debug;

	// instantiate the request obj
	var httpconn = null;
	try	{
		// Instantiates XMLHttpRequest in non-IE browsers and assigns to http.
		// If you read note #1035754, in the post above, you will see that, in IE, if we try to instantiate
		// first the native xmlhtprequest and then an activeX dom object, we might get
		// into trouble, using mismatched versions... oh so typical of them...
		httpconn = new XMLHttpRequest();
	}
	catch(e)
	{
		for(var i = 0; i &lt; _msxml_progid.length; ++i) {
			try	{
				// Instantiates XMLHttpRequest for IE and assign to http.
				httpconn = new ActiveXObject(_msxml_progid[i]);
				break;
			}
			catch(e) {}
		}
	}
	if (httpconn === null)
	{
		var resp = new xmlrpcresp(0, xmlrpcerr['</span>no_curl<span class="literal">'], xmlrpcstr['</span>no_curl<span class="literal">']);
		if (async)
		{
			async(resp);
			return false;
		}
		return resp;
	}

	// Only create the payload if it was not created previously
	if (msg.payload == '</span><span class="literal">')
	{
		msg.createPayload();
	}

	/// @todo add optional deflating of request
	var payload = msg.payload;
	var encoding_hdr = '</span><span class="literal">';

	if (this.debug &gt; 1)
	{
		xmlrpc_debug_log('</span>&lt;PRE&gt;\n---SENDING---\n<span class="literal">'+htmlentities(payload)+'</span>\n---END---\n&lt;/PRE&gt;<span class="literal">');
	}

	try
	{
		if (this.username != '</span><span class="literal">')
		{
			httpconn.open('</span>POST<span class="literal">', method + '</span>:<span class="comment">//' + this.server + port + this.path, Boolean(async), this.username, this.password);</span>
		}
		<span class="reserved">else</span>
		{
			httpconn.open(<span class="literal">'POST'</span>, method + <span class="literal">'://'</span> + <span class="reserved">this</span>.server + port + <span class="reserved">this</span>.path, Boolean(async));
		}
	}
	catch(e)
	{
		<span class="comment">//alert('open failed of '+method + '://' + this.server + port + this.path);</span>
		httpconn = null;
		var resp = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'http_error'</span>], xmlrpcstr[<span class="literal">'http_error'</span>]+<span class="literal">' (open failed)'</span>);
		<span class="reserved">if</span> (async)
		{
			async(resp);
			<span class="reserved">return</span> false;
		}
		<span class="reserved">return</span> resp;
	}

	<span class="comment">// opera 8b does not support setRequestHeader</span>
	try
	{

	<span class="comment">// optionally deny reception of deflated responses</span>
	<span class="reserved">if</span> (<span class="reserved">this</span>.accepted_compression != <span class="literal">'auto'</span>)
	{
		httpconn.setRequestHeader(<span class="literal">'Accept-Encoding'</span>, <span class="reserved">this</span>.accepted_compression.join(<span class="literal">','</span>));
	}

	<span class="comment">/// <span class="attrib">@todo</span> add support for setting cookies by hand</span>

	httpconn.setRequestHeader(<span class="literal">'User-Agent'</span>, xmlrpcName + <span class="literal">' '</span> + xmlrpcVersion);
	httpconn.setRequestHeader(<span class="literal">'Content-type'</span>, msg.content_type);
	<span class="reserved">if</span> (!<span class="reserved">this</span>.keepalive)
	{
		httpconn.setRequestHeader(<span class="literal">'Connection'</span>, <span class="literal">'close'</span>);
		httpconn.setRequestHeader(<span class="literal">'Keep-Alive'</span>, <span class="literal">''</span>); <span class="comment">// harmless on IE, removes header in FF</span>
	}
	<span class="comment">// clear http headers that browsers add on their own</span>

	<span class="comment">// note: we assume that msg type is the same as type of expected response...</span>
	httpconn.setRequestHeader(<span class="literal">'Accept'</span>, msg.content_type);
	<span class="comment">//httpconn.setRequestHeader('Accept-lang', '');</span>

	<span class="comment">// add http header for accepted charsets if user set them explicitly</span>
	<span class="reserved">if</span> (<span class="reserved">this</span>.accepted_charset_encodings != <span class="literal">'auto'</span>)
	{
		httpconn.setRequestHeader(<span class="literal">'Accept-Charset'</span>, <span class="reserved">this</span>.accepted_charset_encodings.join(<span class="literal">','</span>));
	}

	<span class="comment">// this one is set last, because Safari refuses to set it, and possibly raises an exception</span>
	httpconn.setRequestHeader(<span class="literal">'Content-length'</span>, payload.length);

	}
	catch(e) <span class="comment">// exception on call of setRequestHeader(): do nothing</span>
	{
	}

	<span class="reserved">if</span> (async)
	{
		<span class="reserved">if</span> (timeout &gt; 0)
		{
			<span class="comment">// instead of binding to onreadystatechange event, we set up a polling</span>
			<span class="comment">// and abort callbacks after timeout secs</span>
			var client = <span class="reserved">this</span>;
			var tid = <span class="reserved">this</span>.tid;
			<span class="reserved">this</span>.polling_queue[<span class="reserved">this</span>.tid] = [];
			<span class="comment">// save pointers to timers, to make sure they later get deleted</span>
			<span class="reserved">this</span>.polling_queue[<span class="reserved">this</span>.tid][0] = window.setTimeout(<span class="reserved">function</span>(){
				window.clearInterval(client.polling_queue[tid][1]);
				delete client.polling_queue[tid][1];
				delete client.polling_queue[tid][0];
				client.handleTransaction(msg, httpconn, async, true);
			}, timeout*1000);
			<span class="reserved">this</span>.polling_queue[<span class="reserved">this</span>.tid][1] = window.setInterval(<span class="reserved">function</span>(){
				<span class="reserved">if</span> (httpconn.readyState == 4)
				{
					window.clearInterval(client.polling_queue[tid][1]);
					window.clearTimeout(client.polling_queue[tid][0]);
					delete client.polling_queue[tid][1];
					delete client.polling_queue[tid][0];
					client.handleTransaction(msg, httpconn, async, false);
					<span class="comment">//httpconn = null;</span>
				}
			}, <span class="reserved">this</span>.polling_interval);
			++<span class="reserved">this</span>.tid;
		}
		<span class="reserved">else</span>
		{
			var client = <span class="reserved">this</span>;
			<span class="comment">// no timeout defined, be quicker and just use events</span>
			httpconn.onreadystatechange = <span class="reserved">function</span>(){
				<span class="reserved">if</span> (httpconn.readyState == 4)
				{
					<span class="reserved">if</span> (httpconn.status != 200)
					{
						<span class="comment">/// <span class="attrib">@todo</span> check if HTTP 1.1 100 Continue header will get us here or not...</span>
						var resp = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'http_error'</span>], xmlrpcstr[<span class="literal">'http_error'</span>]+<span class="literal">' ( HTTP '</span> + httpconn.status + <span class="literal">' '</span> + httpconn.statusText +<span class="literal">')'</span>);
					}
					<span class="reserved">else</span>
					{
						var resp = msg.parseResponse(httpconn.responseText, httpconn.getAllResponseHeaders(), client.return_type);
					}
					<span class="comment">// make sure objs get destroyed. MIGHT help GC... (taken from other libs...)</span>
					httpconn = null;
					async(resp);
				}
			}
		}
	}

	try
	{
		<span class="comment">/// <span class="attrib">@todo</span> check if we could extract more info from this exception...</span>
		httpconn.send(payload);
	}
	catch(e)
	{
		httpconn = null;
		var resp = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'http_error'</span>], xmlrpcstr[<span class="literal">'http_error'</span>]+<span class="literal">' (send failed)'</span>);
		<span class="reserved">if</span> (async)
		{
			async(resp);
			<span class="reserved">return</span> false;
		}
		<span class="reserved">return</span> resp;
	}

	<span class="reserved">if</span> (!async)
	{
		<span class="reserved">if</span> (httpconn.status != 200)
		{
			<span class="comment">/// <span class="attrib">@todo</span> check if HTTP 1.1 100 Continue header will get us here or not...</span>
			var resp = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'http_error'</span>], xmlrpcstr[<span class="literal">'http_error'</span>]+<span class="literal">' ( HTTP '</span> + httpconn.status + <span class="literal">' '</span> + httpconn.statusText + <span class="literal">')'</span>);
		}
		<span class="reserved">else</span>
		{
			var resp = msg.parseResponse(httpconn.responseText, httpconn.getAllResponseHeaders(), <span class="reserved">this</span>.return_type);
		}
		<span class="comment">// make sure objs get destroyed. MIGHT help GC... (taken from other libs...)</span>
		httpconn = null;
		<span class="reserved">return</span> resp;
	}
}
<span class="comment">/**
 * Handler for async calls http transaction end events
 * <span class="attrib">@private</span>
 **/</span>
xmlrpc_client.<span class="reserved">prototype</span>.handleTransaction = <span class="reserved">function</span>(msg, httpconn, callback, is_timeout)
{
	<span class="reserved">if</span> (is_timeout)
	{
		<span class="comment">// timeout</span>
		<span class="comment">/// <span class="attrib">@todo</span> rumors say that calling abort() on connections in state 0 or 4 raises an error...</span>
		httpconn.abort();
		var resp = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'http_error'</span>], xmlrpcstr[<span class="literal">'http_error'</span>]+<span class="literal">' (send timeout)'</span>);
	}

	<span class="reserved">else</span>
	{
		<span class="comment">// http ok</span>
		<span class="reserved">if</span> (httpconn.status != 200)
		{
			<span class="comment">/// <span class="attrib">@todo</span> check if HTTP 1.1 100 Continue header will get us here or not...</span>
			var resp = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'http_error'</span>], xmlrpcstr[<span class="literal">'http_error'</span>]+<span class="literal">' ( HTTP '</span> + httpconn.status + <span class="literal">' '</span> + httpconn.statusText +<span class="literal">')'</span>);
		}
		<span class="reserved">else</span>
		{
			var resp = msg.parseResponse(httpconn.responseText, httpconn.getAllResponseHeaders(), <span class="reserved">this</span>.return_type);
		}
	}
	callback(resp);
}

<span class="comment">/**
* Send an array of request messages and return an array of responses.
* Unless this.no_multicall has been set to true, it will try first
* to use one single xmlrpc call to server method system.multicall, and
* revert to sending many successive calls in case of failure.
* This failure is also stored in this.no_multicall for subsequent calls.
* Unfortunately, there is no server error code universally used to denote
* the fact that multicall is unsupported, so there is no way to reliably
* distinguish between that and a temporary failure.
* If you are sure that server supports multicall and do not want to
* fallback to using many single calls, set the fourth parameter to FALSE.
*
* <span class="attrib">@param</span> {array} messages an array of xmlrpcmsg objects
* <span class="attrib">@param</span> {integer} timeout Not in use (yet). Connection timeout (in seconds) for every single request made
* <span class="attrib">@param</span> {string} method The http protocol variant to be used. If undefined, defaults to the variant used at obj creation time. Not in use (yet)
* <span class="attrib">@param</span> {boolean} fallback When true (the default value), upon receiveing an error during multicall, multiple single calls will be attempted
* <span class="attrib">@type</span> array
* <span class="attrib">@public</span>
*/</span>
xmlrpc_client.<span class="reserved">prototype</span>.multiCall = <span class="reserved">function</span> (messages, timeout, method, fallback)
{
	<span class="comment">// NB: trying to shoehorn extra functionality into existing syntax has resulted</span>
	<span class="comment">// in pretty much convoluted code...</span>

	<span class="reserved">if</span> (fallback == undefined)
	{
		fallback = true;
	}
	<span class="reserved">if</span> (method == undefined)
	{
		method = <span class="reserved">this</span>.method;
	}

	<span class="reserved">if</span> (!<span class="reserved">this</span>.no_multicall)
	{
		var results = <span class="reserved">this</span>._try_multicall(messages, timeout, method);
		<span class="reserved">if</span> (results instanceof Array)
		{
			<span class="comment">// System.multicall succeeded</span>
			<span class="reserved">return</span> results;
		}
		<span class="reserved">else</span>
		{
			<span class="comment">// either system.multicall is unsupported by server,</span>
			<span class="comment">// or call failed for some other reason.</span>
			<span class="reserved">if</span> (fallback)
			{
				<span class="comment">// Don't try it next time...</span>
				<span class="reserved">this</span>.no_multicall = true;
			}
			<span class="reserved">else</span>
			{
				<span class="reserved">if</span> (results instanceof xmlrpcresp)
				{
					var result = results;
				}
				<span class="reserved">else</span>
				{
					var result = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'multicall_error'</span>], xmlrpcstr[<span class="literal">'multicall_error'</span>]);
				}
			}
		}
	}
	<span class="reserved">else</span>
	{
		<span class="comment">// override fallback, in case careless user tries to do two</span>
		<span class="comment">// opposite things at the same time</span>
		fallback = true;
		var results;
	}

	results = array();
	<span class="reserved">if</span> (fallback)
	{
		<span class="comment">// system.multicall is (probably) unsupported by server:</span>
		<span class="comment">// emulate multicall via multiple requests</span>
		<span class="reserved">for</span>(var i = 0; i &lt; messages.length; ++i)
		{
			results[results.length] = <span class="reserved">this</span>.send(messages[i], timeout, method);
		}
	}
	<span class="reserved">else</span>
	{
		<span class="comment">// user does NOT want to fallback on many single calls:</span>
		<span class="comment">// since we should always return an array of responses,</span>
		<span class="comment">// return an array with the same error repeated n times</span>
		<span class="reserved">for</span>(var i = 0; i &lt; messages.length; ++i)
		{
			results[results.length] = result;
		}
	}
	<span class="reserved">return</span> results;
}

<span class="comment">/**
* Attempt to boxcar msgs via system.multicall.
* Returns either an array of xmlrpcreponses, an xmlrpc error response
* or false (when received response does not respect valid multicall syntax)
* <span class="attrib">@private</span>
*/</span>
xmlrpc_client.<span class="reserved">prototype</span>._try_multicall = <span class="reserved">function</span> (msgs, timeout, method)
{
	<span class="comment">// Construct multicall message</span>
	var calls = [];
	var call = {}
	var numParams;
	var msg;
	var params;
	<span class="reserved">for</span>(var i = 0; i &lt; msgs.length; ++i)
	{
		msg = msgs[i];
		call[<span class="literal">'methodName'</span>] = new xmlrpcval(msgs.method(),<span class="literal">'string'</span>);
		numParams = msg.getNumParams();
		params = [];
		<span class="reserved">for</span>(var j = 0; j &lt; numParams; ++j)
		{
			params[j] = msg.getParam(j);
		}
		call[<span class="literal">'params'</span>] = new xmlrpcval(params, <span class="literal">'array'</span>);
		calls[i] = new xmlrpcval(call, <span class="literal">'struct'</span>);
	}
	var multicall = new xmlrpcmsg(<span class="literal">'system.multicall'</span>);
	multicall.addParam(new xmlrpcval(calls, <span class="literal">'array'</span>));

	<span class="comment">// Attempt RPC call</span>
	var result = <span class="reserved">this</span>.send(multicall, timeout, method);

	<span class="reserved">if</span> (result.faultCode() != 0)
	{
		<span class="comment">// call to system.multicall failed</span>
		<span class="reserved">return</span> result;
	}

	<span class="comment">// Unpack responses.</span>
	var rets = result.value();

	<span class="reserved">if</span> (<span class="reserved">this</span>.return_type == <span class="literal">'xml'</span>)
	{
		<span class="reserved">return</span> rets;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.return_type == <span class="literal">'jsvals'</span>)
	{
		rets = result.value();
		<span class="reserved">if</span> (!rets instanceof Array)
		{
			<span class="reserved">return</span> false;		<span class="comment">// bad return type from system.multicall</span>
		}
		var numRets = rets.length;
		<span class="reserved">if</span> (numRets != msgs.length)
		{
			<span class="reserved">return</span> false;		<span class="comment">// wrong number of return values.</span>
		}

		var response = [];
		var val;
		<span class="reserved">for</span>(i = 0; i &lt; numRets; ++i)
		{
			val = rets[i];
			<span class="comment">// in Js, val can either be a single-valued array, or an anonobj here...</span>
			<span class="comment">//if (!val instanceof Array)</span>
			<span class="comment">//{</span>
			<span class="comment">//	return false;</span>
			<span class="comment">//}</span>
			switch(val.length)
			{
				case 1:
					<span class="reserved">if</span> (val[0] === undefined)
					{
						<span class="reserved">return</span> false;		<span class="comment">// Bad value</span>
					}
					<span class="comment">// Normal return value</span>
					response[i] = new xmlrpcresp(val[0], 0, <span class="literal">''</span>, <span class="literal">'jsvals'</span>);
					break;
				case 2:
					try
					{
						var code = val[<span class="literal">'faultCode'</span>];
						<span class="reserved">if</span> (typeof(code) != <span class="literal">'number'</span>)
						{
							<span class="reserved">return</span> false;
						}
						var str = val[<span class="literal">'faultString'</span>];
						<span class="reserved">if</span> (typeof(str) != <span class="literal">'string'</span>)
						{
							<span class="reserved">return</span> false;
						}
						response[i] = new xmlrpcresp(0, code, str);
					}
					catch (e)
					{
						<span class="reserved">return</span> false;
					}
					break;
				default:
					<span class="reserved">return</span> false;
			}
		}
		<span class="reserved">return</span> response;
	}
	<span class="reserved">else</span> <span class="comment">// return type == 'xmlrpcvals'</span>
	{
		rets = result.value();
		<span class="reserved">if</span> (rets.kindOf() != <span class="literal">'array'</span>)
		{
			<span class="reserved">return</span> false;		<span class="comment">// bad return type from system.multicall</span>
		}
		var numRets = rets.arraysize();
		<span class="reserved">if</span> (numRets != msgs.length)
		{
			<span class="reserved">return</span> false;		<span class="comment">// wrong number of return values.</span>
		}

		var response = [];
		var val;
		<span class="reserved">for</span>(i = 0; i &lt; numRets; ++i)
		{
			val = rets.arraymem(i);
			switch(val.kindOf())
			{
				case <span class="literal">'array'</span>:
					<span class="reserved">if</span> (val.arraySize() != 1)
					{
						<span class="reserved">return</span> false;		<span class="comment">// Bad value</span>
					}
					<span class="comment">// Normal return value</span>
					response[i] = new xmlrpcresp(val.arrayMem(0));
					break;
				case <span class="literal">'struct'</span>:
					var code = val.structmem(<span class="literal">'faultCode'</span>);
					<span class="reserved">if</span> (code.kindOf() != <span class="literal">'scalar'</span> || code.scalarTyp() != <span class="literal">'int'</span>)
					{
						<span class="reserved">return</span> false;
					}
					var str = val.structmem(<span class="literal">'faultString'</span>);
					<span class="reserved">if</span> (str.kindOf() != <span class="literal">'scalar'</span> || str.scalarTyp() != <span class="literal">'string'</span>)
					{
						<span class="reserved">return</span> false;
					}
					response[i] = new xmlrpcresp(0, code.scalarVal(), str.scalarVal());
					break;
				default:
					<span class="reserved">return</span> false;
			}
		}
		<span class="reserved">return</span> response;
	}
}

<span class="comment">/******************************************************************************/</span>
<span class="comment">/**
* Create an xmlrpcval object out of a plain javascript value
* <span class="attrib">@param</span> {mixed} val
* <span class="attrib">@param</span> {string} type Any valid xmlrpc type name (lowercase). If omitted, 'string' is assumed
* <span class="attrib">@constructor</span>
*/</span>
<span class="reserved">function</span> xmlrpcval (val, type)
{
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.me = null;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.mytype = 0;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>._js_class = <span class="literal">''</span>;

	<span class="reserved">this</span>.init(val, type);
}

<span class="comment">/**
* <span class="attrib">@param</span> {mixed} val
* <span class="attrib">@param</span> {string} type Any valid xmlrpc type name (lowercase). If null, 'string' is assumed
* <span class="attrib">@private</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.init = <span class="reserved">function</span> (val, type) {
	<span class="reserved">if</span> (val !== undefined)
	{
		<span class="reserved">this</span>.me = val;
		switch(type)
		{
			case <span class="literal">'string'</span>:
			case undefined:
			case <span class="literal">''</span>:
				<span class="reserved">this</span>.mytype = 1;
				break;
			case <span class="literal">'i4'</span>:
			case <span class="literal">'int'</span>:
				<span class="reserved">this</span>.mytype = 4;
				break;
			case <span class="literal">'double'</span>:
				<span class="reserved">this</span>.mytype = 5;
				break;
			case <span class="literal">'boolean'</span>:
				<span class="reserved">this</span>.mytype = 6;
				break;
			case <span class="literal">'dateTime.iso8601'</span>:
				<span class="reserved">this</span>.mytype = 7;
				break;
			case <span class="literal">'base64'</span>:
				<span class="reserved">this</span>.mytype = 8;
				break;
			case <span class="literal">'null'</span>:
				<span class="reserved">this</span>.mytype = 9; <span class="comment">// shall we be content with type 0?</span>
				break;
			case <span class="literal">'array'</span>:
				<span class="reserved">this</span>.mytype = 2;
				break;
			case <span class="literal">'struct'</span>:
				<span class="reserved">this</span>.mytype = 3;
				<span class="reserved">this</span>.myidx = 0;
				break;
			default:
				xmlrpc_error_log(<span class="literal">'XML-RPC: xmlrpcval::xmlrpcval: not a known type ('</span>+type+<span class="literal">')'</span>);
		}
	}
}

<span class="comment">/**
* Add a single javascript value to an (uninitialized) xmlrpcval
* <span class="attrib">@param</span> {mixed} val
* <span class="attrib">@param</span> {string} type
* <span class="attrib">@return</span> 1 or 0 on failure
* <span class="attrib">@type</span> integer
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.addScalar = <span class="reserved">function</span> (val, type) {
	<span class="reserved">if</span> (type === undefined)
		type = <span class="literal">'string'</span>;
	<span class="reserved">if</span> (xmlrpcTypes[type] === undefined)
	{
		xmlrpc_error_log(<span class="literal">'XML-RPC: xmlrpcval::addScalar: not a scalar type ('</span>+type+<span class="literal">')'</span>);
		<span class="reserved">return</span> 0;
	}

	<span class="comment">// coerce booleans into correct values</span>
	<span class="comment">// NB: we should iether do it for datetimes, integers and doubles, too,</span>
	<span class="comment">// or just plain remove this check, implemnted on booleans only...</span>
	<span class="comment">/*if ($type==$GLOBALS['xmlrpcBoolean'])
	{
		if (strcasecmp($val,'true')==0 || $val==1 || ($val==true &amp;&amp; strcasecmp($val,'false')))
		{
			$val=true;
		}
		else
		{
			$val=false;
		}
	}*/</span>

	switch(<span class="reserved">this</span>.mytype)
	{
		case 0:
			<span class="comment">// a scalar, so set the value and remember we're scalar</span>
			<span class="reserved">this</span>.me = val;
			<span class="reserved">this</span>.mytype = xmlrpcTypes[type];
			<span class="reserved">return</span> 1;
		case 2:
			<span class="comment">// we're adding a scalar value to an array here</span>
			<span class="reserved">this</span>.me[<span class="reserved">this</span>.me.lenght] = new xmlrpcval(val, type);
			<span class="reserved">return</span> 1;
		case 3:
			xmlrpc_error_log(<span class="literal">'XML-RPC: xmlrpcval::addScalar: cannot add anonymous scalar to struct xmlrpcval'</span>);
			<span class="reserved">return</span> 0;
		default:
			xmlrpc_error_log(<span class="literal">'XML-RPC: xmlrpcval::addScalar: scalar xmlrpcval can have only one value'</span>);
			<span class="reserved">return</span> 0;
	}
}

<span class="comment">/**
* Add an array of xmlrpcval objects to an xmlrpcval (of type array or uninitialized)
* <span class="attrib">@param</span> {array} vals An array, whose members are xmlrpcvals
* <span class="attrib">@return</span> 1 or 0 on failure
* <span class="attrib">@type</span> integer
* <span class="attrib">@public</span>
*
* <span class="attrib">@todo</span> add some checking for vals to be an array of xmlrpcvals?
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.addArray = <span class="reserved">function</span> (vals) {
	<span class="reserved">if</span> (<span class="reserved">this</span>.mytype == 0) {
		<span class="reserved">this</span>.mytype = 2;
		<span class="reserved">this</span>.me = vals;
		<span class="reserved">return</span> 1;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.mytype == 2)
	{
		<span class="comment">// we're adding to an array here</span>
		<span class="reserved">for</span>(var i = 0; i &lt; vals.length; i++)
			<span class="reserved">this</span>.me[<span class="reserved">this</span>.me.length] = vals[i];
		<span class="reserved">return</span> 1;
	}
	<span class="reserved">else</span>
	{
		<span class="comment">//xmlrpc_error_log('XML-RPC: xmlrpcval::addArray: already initialized as a [' . $this.kindOf() . ']');</span>
		<span class="reserved">return</span> 0;
	}
}

<span class="comment">/**
* Add a list (anon obj) of named xmlrpcval objects to an xmlrpcval (of type struct or uninitialized)
* <span class="attrib">@param</span> {object} vals An anonymous object, whose members are xmlrpcvals
* <span class="attrib">@return</span> 1 or 0 on failure
* <span class="attrib">@type</span> integer
* <span class="attrib">@public</span>
*
* <span class="attrib">@todo</span> add some checking for $vals to be an array?
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.addStruct = <span class="reserved">function</span> (vals)	{
	<span class="reserved">if</span> (<span class="reserved">this</span>.mytype == 0)
	{
		<span class="reserved">this</span>.mytype = 3;
		<span class="reserved">this</span>.me = vals;
		<span class="reserved">this</span>.myidx = 0;
		<span class="reserved">return</span> 1;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.mytype == 3)
	{
		<span class="comment">// we're adding to a struct here. we expect an anon obj as parameter...</span>
		<span class="reserved">for</span>(var i in vals)
			<span class="reserved">this</span>.me[i] = vals[i];
		<span class="reserved">return</span> 1;
	}
	<span class="reserved">else</span>
	{
		<span class="comment">//xmlrpc_error_log('XML-RPC: xmlrpcval::addStruct: already initialized as a [' . this.kindOf() . ']');</span>
		<span class="reserved">return</span> 0;
	}
}

<span class="comment">/**
* Returns a string containing "struct", "array" or "scalar" describing the base type of the value
* <span class="attrib">@type</span> string
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.kindOf = <span class="reserved">function</span> () {
	switch(<span class="reserved">this</span>.mytype)
	{
		case 3:
			<span class="reserved">return</span> <span class="literal">'struct'</span>;
		case 2:
			<span class="reserved">return</span> <span class="literal">'array'</span>;
		case 0:
			<span class="reserved">return</span> <span class="literal">'undef'</span>;
		default:
			<span class="comment">// note: this is hoping for nobody havingset this.me to, say, 666...</span>
			<span class="comment">/// <span class="attrib">@todo</span> make this more secure enumerating known scalar types: 1, 4-9</span>
			<span class="reserved">return</span> <span class="literal">'scalar'</span>;
	}
}

<span class="comment">/**
* Returns xml representation of the value. XML prologue not included
* <span class="attrib">@param</span> {string} charset_encoding the charset to be used for serialization. If null, US-ASCII is assumed
* <span class="attrib">@type</span> string
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.serialize = <span class="reserved">function</span> (charset_encoding)
{
	<span class="comment">/// <span class="attrib">@todo</span> coerce scalar types when serializing...</span>
	switch(<span class="reserved">this</span>.mytype)
	{
		case 1:
			var result = <span class="literal">'&lt;string&gt;'</span>+xmlrpc_encode_entities(<span class="reserved">this</span>.me)+<span class="literal">'&lt;/string&gt;'</span>;
			break;
		case 4:
			<span class="reserved">if</span> (isFinite(<span class="reserved">this</span>.me) &amp;&amp; <span class="reserved">this</span>.me !== null)
			{ <span class="comment">/// <span class="attrib">@todo</span> add true and false? looks like isFinite accepts them as valid...</span>
				var result = <span class="literal">'&lt;int&gt;'</span>+<span class="reserved">this</span>.me.toFixed()+<span class="literal">'&lt;/int&gt;'</span>; <span class="comment">// as per Ecma-262, toFixed is better than toString...</span>
			}
			<span class="reserved">else</span>
			{
				var result = <span class="literal">'&lt;int&gt;0&lt;/int&gt;'</span>;
			}
			break;
		case 5:
			<span class="reserved">if</span> (isFinite(<span class="reserved">this</span>.me) &amp;&amp; <span class="reserved">this</span>.me !== null)
			{ <span class="comment">/// <span class="attrib">@todo</span> add true and false? looks like isFinite accepts them as valid...</span>
				var result = <span class="literal">'&lt;double&gt;'</span>+<span class="reserved">this</span>.me.toString()+<span class="literal">'&lt;/double&gt;'</span>;
			}
			<span class="reserved">else</span>
			{
				var result = <span class="literal">'&lt;double&gt;0&lt;/double&gt;'</span>;
			}
			break;
		case 6:
			<span class="reserved">if</span> (<span class="reserved">this</span>.me)
				var result = <span class="literal">'&lt;boolean&gt;1&lt;/boolean&gt;'</span>;
			<span class="reserved">else</span>
				var result = <span class="literal">'&lt;boolean&gt;0&lt;/boolean&gt;'</span>;
			break;
		case 7:
			<span class="comment">// we are assuming we got a string, correctly formatted, here</span>
			<span class="comment">/// <span class="attrib">@todo</span> shall we add some xml-escaping here???</span>
			result = <span class="literal">'&lt;dateTime.iso8601&gt;'</span>+<span class="reserved">this</span>.me+<span class="literal">'&lt;/dateTime.iso8601&gt;'</span>;
			break;
		case 8:
			var result = <span class="literal">'&lt;base64&gt;'</span>+base64_encode(<span class="reserved">this</span>.me)+<span class="literal">'&lt;/base64&gt;'</span>;
			break;
		case 9:
			var result = <span class="literal">'&lt;nil/&gt;'</span>;
			break;
		case 2:
			var result = <span class="literal">'&lt;array&gt;\n&lt;data&gt;\n'</span>;
			<span class="reserved">for</span>(var i = 0; i &lt; <span class="reserved">this</span>.me.length; i++)
			{
				result = result+<span class="reserved">this</span>.me[i].serialize(charset_encoding);
				<span class="comment">//alert(i+': '+this.me[i].kindof()+' - '+this.me[i].scalartyp());</span>
			}
			result = result+<span class="literal">'&lt;/data&gt;\n&lt;/array&gt;'</span>;
			break;
		case 3:
			var result = <span class="literal">'&lt;struct&gt;\n'</span>;
			<span class="reserved">for</span>(var attr in <span class="reserved">this</span>.me)
			{
				result = result+<span class="literal">'&lt;member&gt;&lt;name&gt;'</span>+xmlrpc_encode_entities(attr)+<span class="literal">'&lt;/name&gt;\n'</span>+<span class="reserved">this</span>.me[attr].serialize(charset_encoding)+<span class="literal">'&lt;/member&gt;\n'</span>;
				<span class="comment">//alert(attr+': '+this.me[attr].kindof()+' - '+this.me[attr].scalartyp());</span>
			}
			result = result+<span class="literal">'&lt;/struct&gt;'</span>;
			break;
		default:
			var result = <span class="literal">''</span>;
	}
	<span class="reserved">return</span> <span class="literal">'&lt;value&gt;'</span>+result+<span class="literal">'&lt;/value&gt;\n'</span>;
}

<span class="comment">/**
* Checks wheter a struct member with a given name is present.
* Works only on xmlrpcvals of type struct.
* <span class="attrib">@param</span> {string} m the name of the struct member to be looked up
* <span class="attrib">@type</span> boolean
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.structMemExists = <span class="reserved">function</span>(m) {
	<span class="reserved">for</span>(var attr in <span class="reserved">this</span>.me)
		<span class="reserved">if</span> (attr == m)
			<span class="reserved">return</span> true;
	<span class="reserved">return</span> false;
}

<span class="comment">/**
* Returns the value of a given struct member (an xmlrpcval object in itself).
* <span class="attrib">@param</span> {string} m the name of the struct member to be looked up
* <span class="attrib">@return</span> undefined if no such member exists
* <span class="attrib">@type</span> xmlrpcval
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.structMem = <span class="reserved">function</span>(m) {
	<span class="reserved">return</span> <span class="reserved">this</span>.me[m];
}

<span class="comment">/**
* Reset internal pointer for xmlrpcvals of type struct.
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.structReset = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.myidx = 0;
}

<span class="comment">/**
* Returns next member element for xmlrpcvals of type struct.
* <span class="attrib">@return</span> An anon obj with members 0,key =&gt; element name, 1,value =&gt; element val, or false upon reaching end of struct
* <span class="attrib">@type</span> object
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.structEach = <span class="reserved">function</span>() {
	++<span class="reserved">this</span>.myidx;
	var i = 0;
	<span class="reserved">for</span> (var attr in <span class="reserved">this</span>.me) {
		++i;
		<span class="reserved">if</span> (i == <span class="reserved">this</span>.myidx) {
			<span class="reserved">return</span> {0:attr, 1:<span class="reserved">this</span>.me[attr], key:attr, value:<span class="reserved">this</span>.me[attr]} <span class="comment">// same as php array returned by each()</span>
		}
	}
	<span class="reserved">return</span> false;
}

<span class="comment">/**
* Returns the value of a scalar xmlrpcval
* <span class="attrib">@type</span> mixed
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.scalarVal = <span class="reserved">function</span> () {
	<span class="reserved">return</span> <span class="reserved">this</span>.me;
}

<span class="comment">/**
* Returns the type of the xmlrpcval.
* For integers, 'int' is always returned in place of 'i4'
* <span class="attrib">@type</span> string
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.scalarTyp = <span class="reserved">function</span> () {
	switch(<span class="reserved">this</span>.mytype)
	{
		case 3:
			<span class="reserved">return</span> <span class="literal">'struct'</span>;
		case 2:
			<span class="reserved">return</span> <span class="literal">'array'</span>;
		case 1:
			<span class="reserved">return</span> <span class="literal">'string'</span>;
		case 4:
			<span class="reserved">return</span> <span class="literal">'int'</span>;
		case 5:
			<span class="reserved">return</span> <span class="literal">'double'</span>;
		case 6:
			<span class="reserved">return</span> <span class="literal">'boolean'</span>;
		case 7:
			<span class="reserved">return</span> <span class="literal">'dateTime.iso8601'</span>;
		case 8:
			<span class="reserved">return</span> <span class="literal">'base64'</span>;
		case 9:
			<span class="reserved">return</span> <span class="literal">'null'</span>;
		case 0:
			<span class="reserved">return</span> <span class="literal">'undef'</span>;
		default:
			<span class="reserved">return</span> <span class="literal">'undef: '</span>+<span class="reserved">this</span>.mytype; <span class="comment">// on php version raises a warning instead</span>
	}
}

<span class="comment">/**
* Returns the m-th member of an xmlrpcval of array type
* <span class="attrib">@param</span> {integer} m the index of the value to be retrieved (zero based).
* <span class="attrib">@return</span> undefined if there is no such element
* <span class="attrib">@type</span> xmlrpcval
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.arrayMem = <span class="reserved">function</span>(m) {
	<span class="reserved">return</span> <span class="reserved">this</span>.me[m];
}

<span class="comment">/**
* Returns the number of members in an xmlrpcval of array type
* <span class="attrib">@type</span> integer
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.arraySize = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.me.length;
}

<span class="comment">/**
* Returns the number of members in an xmlrpcval of struct type
* <span class="attrib">@type</span> integer
* <span class="attrib">@public</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.structSize = <span class="reserved">function</span>() {
	var i = 0;
	<span class="reserved">for</span>(var attr in <span class="reserved">this</span>.me)
		++i;
	<span class="reserved">return</span> i;
}

<span class="comment">/**
* <span class="attrib">@type</span> xmlrpcval
* <span class="attrib">@private</span>
*/</span>
xmlrpcval.<span class="reserved">prototype</span>.toXmlRpcVal = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>;
}

<span class="comment">/******************************************************************************/</span>
<span class="comment">/**
* <span class="attrib">@param</span> {string} meth Name of the method to be invoked
* <span class="attrib">@param</span> {array} pars list of parameters for method call (xmlrpcval objects)
* <span class="attrib">@constructor</span>
*/</span>
<span class="reserved">function</span> xmlrpcmsg(meth, pars) {
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.methodname = <span class="literal">''</span>;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.params = [];
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.payload = <span class="literal">''</span>;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.debug = 0;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.content_type = <span class="literal">'text/xml'</span>;

	<span class="reserved">this</span>.init(meth, pars);
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.init = <span class="reserved">function</span>(meth, pars) {
	<span class="reserved">this</span>.methodname = meth;
	<span class="reserved">if</span> (pars != undefined)
	{
		<span class="reserved">for</span>(var i = 0; i &lt; pars.length; ++i)
		{
			<span class="reserved">this</span>.addParam(pars[i]);
		}
	}
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.kindOf = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="literal">'msg'</span>;
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.xml_header = <span class="reserved">function</span> (charset_encoding) {
	<span class="reserved">if</span> (charset_encoding != undefined &amp;&amp; charset_encoding != <span class="literal">''</span>)
	{
		<span class="reserved">return</span> <span class="literal">'&lt;?xml version="1.0" encoding="'</span>+charset_encoding+<span class="literal">'" ?'</span> + <span class="literal">'&gt;\n&lt;methodCall&gt;\n'</span>;
	}
	<span class="reserved">else</span>
	{
		<span class="reserved">return</span> <span class="literal">'&lt;?xml version="1.0"?'</span> + <span class="literal">'&gt;\n&lt;methodCall&gt;\n'</span>;
	}
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.xml_footer = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="literal">'&lt;/methodCall&gt;'</span>;
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.createPayload = <span class="reserved">function</span> (charset_encoding) {
	<span class="reserved">if</span> (charset_encoding != undefined &amp;&amp; charset_encoding != <span class="literal">''</span>)
		<span class="reserved">this</span>.content_type = <span class="literal">'text/xml; charset='</span> + charset_encoding;
	<span class="reserved">else</span>
		<span class="reserved">this</span>.content_type = <span class="literal">'text/xml'</span>;
	<span class="reserved">this</span>.payload = <span class="reserved">this</span>.xml_header(charset_encoding);
	<span class="reserved">this</span>.payload = <span class="reserved">this</span>.payload + <span class="literal">'&lt;methodName&gt;'</span> + xmlrpc_encode_entities(<span class="reserved">this</span>.methodname) + <span class="literal">'&lt;/methodName&gt;\n'</span>;
	<span class="reserved">this</span>.payload = <span class="reserved">this</span>.payload + <span class="literal">'&lt;params&gt;\n'</span>;
	<span class="reserved">for</span>(var i = 0; i &lt; <span class="reserved">this</span>.params.length; i++)
	{
		<span class="reserved">this</span>.payload = <span class="reserved">this</span>.payload + <span class="literal">'&lt;param&gt;\n'</span> + <span class="reserved">this</span>.params[i].serialize(charset_encoding) +
			<span class="literal">'&lt;/param&gt;\n'</span>;
	}
	<span class="reserved">this</span>.payload = <span class="reserved">this</span>.payload + <span class="literal">'&lt;/params&gt;\n'</span>;
	<span class="reserved">this</span>.payload = <span class="reserved">this</span>.payload + <span class="reserved">this</span>.xml_footer();
}

<span class="comment">/**
* Gets/sets the xmlrpc method to be invoked
* <span class="attrib">@param</span> {string} meth the method to be set (leave empty not to set it)
* <span class="attrib">@return</span> the method that will be invoked
* <span class="attrib">@type</span> string
* <span class="attrib">@public</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.method = <span class="reserved">function</span> (meth)
{
	<span class="reserved">if</span> (meth != undefined &amp;&amp; meth != <span class="literal">''</span>)
	{
		<span class="reserved">this</span>.methodname = meth;
	}
	<span class="reserved">return</span> <span class="reserved">this</span>.methodname;
}

<span class="comment">/**
* Returns xml representation of the message. XML prologue included
* <span class="attrib">@param</span> {string} cahrset_encoding The charset to be used for serialization. If null, US-ASCII is assumed
* <span class="attrib">@return</span> the xml representation of the message, xml prologue included
* <span class="attrib">@type</span> string
* <span class="attrib">@public</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.serialize = <span class="reserved">function</span> (charset_encoding)
{
	<span class="reserved">this</span>.createPayload(charset_encoding);
	<span class="reserved">return</span> <span class="reserved">this</span>.payload;
}

<span class="comment">/**
* Add a parameter to the list of parameters to be used upon method invocation
* <span class="attrib">@param</span> {xmlrpcval} par
* <span class="attrib">@return</span> false on failure (when parameter par is not of correct type)
* <span class="attrib">@type</span> boolean
* <span class="attrib">@public</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.addParam = <span class="reserved">function</span> (par) {
	<span class="comment">/// <span class="attrib">@todo</span>: add check: do not add to self params which are not xmlrpcvals</span>
	<span class="reserved">if</span> (typeof(par) == <span class="literal">'object'</span>) <span class="comment">// &amp;&amp; )</span>
	{
		<span class="reserved">this</span>.params[<span class="reserved">this</span>.params.length] = par;
		<span class="reserved">return</span> true;
	}
	<span class="reserved">else</span>
	{
		<span class="reserved">return</span> false;
	}
}

<span class="comment">/**
* Returns the nth parameter in the message. The index zero-based.
* <span class="attrib">@param</span> {integer} i the index of the parameter to fetch (zero based)
* <span class="attrib">@return</span> the i-th parameter (undefined if index i is bigger than current number of params)
* <span class="attrib">@type</span> xmlrpcval
* <span class="attrib">@public</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.getParam = <span class="reserved">function</span> (i) { <span class="reserved">return</span> <span class="reserved">this</span>.params[i]; }

<span class="comment">/**
* Returns the number of parameters in the messge.
* <span class="attrib">@return</span> the number of parameters currently set
* <span class="attrib">@type</span> integer
* <span class="attrib">@public</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.getNumParams = <span class="reserved">function</span> () { <span class="reserved">return</span> <span class="reserved">this</span>.params.length; }

<span class="comment">/**
* Returns the responde body (string) minus http headers, or an xmlrpcresp obj on error
* <span class="attrib">@private</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.parseResponseHeaders = <span class="reserved">function</span> (data, headers_processed) {
	<span class="reserved">if</span> (headers_processed === undefined)
	{
		headers_processed = false;
	}
	var pos, bd;

	<span class="comment">// NOTE: the http headers received from xmlhttprequest in browser-based hosts</span>
	<span class="comment">// do NOT include the status code.</span>

	<span class="comment">// Support "web-proxy-tunelling" connections for https through proxies</span>
	<span class="reserved">if</span> (data.search(/^HTTP\/1\.[0-1] 200 Connection established/) != -1)
	{
		<span class="comment">// Look for CR/LF or simple LF as line separator,</span>
		<span class="comment">// (even though it is not valid http)</span>
		pos = data.indexOf(<span class="literal">'\r\n\r\n'</span>);
		<span class="reserved">if</span> (pos != -1)
		{
			bd = pos + 4;
		}
		<span class="reserved">else</span>
		{
			pos = data.indexOf(<span class="literal">'\n\n'</span>);
			<span class="reserved">if</span> (pos != -1)
			{
				bd = pos + 2;
			}
			<span class="reserved">else</span>
			{
				<span class="comment">// No separation between response headers and body: fault?</span>
				bd = 0;
			}
		}
		<span class="reserved">if</span> (bd)
		{
			<span class="comment">// this filters out all http headers from proxy.</span>
			<span class="comment">// maybe we could take them into account, too?</span>
			data = data.slice(bd);
		}
		<span class="reserved">else</span>
		{
			xmlrpc_error_log(<span class="literal">'XML-RPC: xmlrpcmsg::parseResponse: HTTPS via proxy error, tunnel connection possibly failed'</span>);
			var r = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'http_error'</span>], xmlrpcstr[<span class="literal">'http_error'</span>] + <span class="literal">' (HTTPS via proxy error, tunnel connection possibly failed)'</span>);
			<span class="reserved">return</span> r;
		}
	}

	<span class="comment">// Strip HTTP 1.1 100 Continue header if present</span>
	<span class="reserved">while</span>(data.search(/^HTTP\/1\.1 1[0-9]{2} /) != -1)
	{
		pos = data.indexOf(<span class="literal">'HTTP'</span>, 12);
		<span class="comment">// server sent a Continue header without any (valid) content following...</span>
		<span class="comment">// give the client a chance to know it</span>
		<span class="reserved">if</span> (pos == -1)
		{
			break;
		}
		data = data.substr(pos);
	}

	var ar = data.match(/^HTTP\/[0-9.]+ ([0-9]{3}) /);
	<span class="reserved">if</span> (ar != null &amp;&amp; ar[0] != <span class="literal">'200'</span>)
	{
		var errstr = (data.indexOf(<span class="literal">'\n'</span>) != -1) ? data.substring(0, data.indexOf(<span class="literal">'\n'</span>)-1) : data;
		xmlrpc_error_log(<span class="literal">'XML-RPC: xmlrpcmsg::parseResponse: HTTP error, got response: '</span> + errstr);
		var r = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'http_error'</span>], xmlrpcstr[<span class="literal">'http_error'</span>] + <span class="literal">' ('</span> + errstr + <span class="literal">')'</span>);
		<span class="reserved">return</span> r;
	}

	_xh[<span class="literal">'headers'</span>] = {};
	_xh[<span class="literal">'cookies'</span>] = {};

	<span class="comment">// be tolerant to usage of \n instead of \r\n to separate headers and data</span>
	<span class="comment">// (even though it is not valid http)</span>
	pos = data.indexOf(<span class="literal">'\r\n\r\n'</span>);
	<span class="reserved">if</span> (pos != -1)
	{
		bd = pos + 4;
	}
	<span class="reserved">else</span>
	{
		pos = data.indexOf(<span class="literal">'\n\n'</span>);
		<span class="reserved">if</span> (pos != -1)
		{
			bd = pos + 2;
		}
		<span class="reserved">else</span>
		{
			<span class="comment">// No separation between response headers and body: fault?</span>
			<span class="comment">// we could take some action here instead of going on...</span>
			bd = 0;
			pos = data.length;
		}
	}

	<span class="comment">// be tolerant to line endings, and extra empty lines</span>
	ar = data.substring(0, pos).replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>).split(/\r?\n/);
	var line, arr;
	<span class="reserved">for</span>(var i = 0; i &lt; ar.length; ++i)
	{
		line = ar[i];
		<span class="comment">// take care of multi-line headers and cookies</span>
		arr = line.split(<span class="literal">':'</span>);
		<span class="reserved">if</span> (arr.length &gt; 1)
		{
			<span class="comment">// re-glue together all the stuff found after the first semicolon (header value)</span>
			<span class="reserved">for</span>(var j = 2; j &lt; arr.length; ++j)
				arr[1] += <span class="literal">':'</span> + arr[j];

			var header_name = arr[0].replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>).toLowerCase();
			<span class="comment">/// <span class="attrib">@todo</span> some other headers (the ones that allow a CSV list of values)</span>
			<span class="comment">/// do allow many values to be passed using multiple header lines.</span>
			<span class="comment">/// We should add content to _xh['headers'][header_name]</span>
			<span class="comment">/// instead of replacing it for those...</span>
			<span class="reserved">if</span> (header_name == <span class="literal">'set-cookie'</span> || header_name == <span class="literal">'set-cookie2'</span>)
			{
				<span class="reserved">if</span> (header_name == <span class="literal">'set-cookie2'</span>)
				{
					<span class="comment">// version 2 cookies:</span>
					<span class="comment">// there could be many cookies on one line, comma separated</span>
					var cookies = arr[1].split(<span class="literal">','</span>);
				}
				<span class="reserved">else</span>
				{
					var cookies = [arr[1]];
				}
				<span class="reserved">for</span>(j = 0; j &lt; cookies.length; ++j)
				{
					var cookie = cookies[j];
					<span class="comment">// glue together all received cookies, using a comma to separate them</span>
					<span class="comment">// (same as php does with getallheaders())</span>
					<span class="reserved">if</span> (_xh[<span class="literal">'headers'</span>][header_name] !== undef)
						_xh[<span class="literal">'headers'</span>][header_name] += <span class="literal">', '</span> + cookie.replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>);
					<span class="reserved">else</span>
						_xh[<span class="literal">'headers'</span>][header_name] = cookie.replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>);
					<span class="comment">// parse cookie attributes, in case user wants to correctly honour them</span>
					<span class="comment">// feature creep: only allow rfc-compliant cookie attributes?</span>
					cookie = cookie.split(<span class="literal">';'</span>);
					<span class="reserved">for</span>(var k = 0; k &lt; cookie.length; ++k)
					{
						var val = cookie[k].split(<span class="literal">'='</span>);
						<span class="reserved">if</span> (val.length == 1)
							val[1] = <span class="literal">''</span>;
						<span class="reserved">else</span> <span class="reserved">if</span> (val.length &gt; 1)
						{
							<span class="reserved">for</span>(var l = 2; l &lt; val.length; ++l)
								val[1] += <span class="literal">'='</span> + val[l];
						}
						var tag = val[0].replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>);
						val = val[1].replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>);
						<span class="comment">/// <span class="attrib">@todo</span> with version 1 cookies, we should strip leading and trailing " chars</span>
						<span class="reserved">if</span> (k == 0)
						{
							var cookiename = tag;
							_xh[<span class="literal">'cookies'</span>][tag] = [];
							_xh[<span class="literal">'cookies'</span>][cookiename][<span class="literal">'value'</span>] = decodeURIComponent(val);
						}
						<span class="reserved">else</span>
						{
							_xh[<span class="literal">'cookies'</span>][cookiename][tag] = val;
						}
					}
				}
			}
			<span class="reserved">else</span>
			{
				_xh[<span class="literal">'headers'</span>][header_name] = arr[1].replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>);
			}
		}
		<span class="reserved">else</span> <span class="reserved">if</span> (header_name !== undefined)
		{
			<span class="comment">///	<span class="attrib">@todo</span> version1 cookies might span multiple lines, thus breaking the parsing above</span>
			_xh[<span class="literal">'headers'</span>][header_name] += <span class="literal">' '</span> + line.replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>);
		}
	}

	data = data.slice(0, bd);

	<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
	{
		xmlrpc_debug_log(<span class="literal">'&lt;PRE&gt;'</span>);
		<span class="reserved">for</span>(i in _xh[<span class="literal">'headers'</span>])
		{
			xmlrpc_debug_log(htmlentities(<span class="literal">'HEADER: '</span> + i + <span class="literal">': '</span> + _xh[<span class="literal">'headers'</span>][i]));
		}
		<span class="reserved">for</span>(i in _xh[<span class="literal">'cookies'</span>])
		{
			xmlrpc_debug_log(htmlentities(<span class="literal">'COOKIE: '</span> + i + <span class="literal">'='</span> + _xh[<span class="literal">'cookies'</span>][i]));
		}
		xmlrpc_debug_log(<span class="literal">'&lt;/PRE&gt;'</span>);
	}

	<span class="comment">// if a browser's xmlhttreq. obj was used for the call, http headers have been processed,</span>
	<span class="comment">// and dechunking + reinflating have been carried out</span>
	<span class="reserved">if</span> (!headers_processed)
	{
		<span class="comment">/**
		TO BE DONE
		// Decode chunked encoding sent by http 1.1 servers
		if (isset(_xh['headers']['transfer-encoding']) &amp;&amp; _xh['headers']['transfer-encoding'] == 'chunked')
		{
			if (!$data = decode_chunked($data))
			{
				xmlrpc_error_log('XML-RPC: xmlrpcmsg::parseResponse: errors occurred when trying to rebuild the chunked data received from server');
				var r = new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['dechunk_fail'], $GLOBALS['xmlrpcstr']['dechunk_fail']);
				return r;
			}
		}
		// Decode gzip-compressed stuff
		// code shamelessly inspired from nusoap library by Dietrich Ayala
		if (isset(_xh['headers']['content-encoding']))
		{
			_xh['headers']['content-encoding'] = str_replace('x-', '', _xh['headers']['content-encoding']);
			if (_xh['headers']['content-encoding'] == 'deflate' || _xh['headers']['content-encoding'] == 'gzip')
			{
				// if decoding works, use it. else assume data wasn't gzencoded
				if (function_exists('gzinflate'))
				{
					if (_xh['headers']['content-encoding'] == 'deflate' &amp;&amp; $degzdata = <span class="attrib">@gzuncompress</span>($data))
					{
						$data = $degzdata;
						if ($this.debug)
							print "&lt;PRE&gt;---INFLATED RESPONSE---[".strlen($data)." chars]---\n" . htmlentities($data) . "\n---END---&lt;/PRE&gt;";
					}
					elseif (_xh['headers']['content-encoding'] == 'gzip' &amp;&amp; $degzdata = <span class="attrib">@gzinflate</span>(substr($data, 10)))
					{
						$data = $degzdata;
						if ($this.debug)
							print "&lt;PRE&gt;---INFLATED RESPONSE---[".strlen($data)." chars]---\n" . htmlentities($data) . "\n---END---&lt;/PRE&gt;";
					}
					else
					{
						xmlrpc_error_log('XML-RPC: xmlrpcmsg::parseResponse: errors occurred when trying to decode the deflated data received from server');
						var r = new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['decompress_fail'], $GLOBALS['xmlrpcstr']['decompress_fail']);
						return r;
					}
				}
				else
				{
					xmlrpc_error_log('XML-RPC: xmlrpcmsg::parseResponse: the server sent deflated data. Your php install must have the Zlib extension compiled in to support this.');
					var r = new xmlrpcresp(0, $GLOBALS['xmlrpcerr']['cannot_decompress'], $GLOBALS['xmlrpcstr']['cannot_decompress']);
					return r;
				}
			}
		}
		**/</span>
	} <span class="comment">// end of 'if needed, de-chunk, re-inflate response'</span>

	<span class="comment">// Js misses cal-by-ref, so we pass back the string we received, minus http headers</span>
	<span class="reserved">return</span> data;
}

<span class="comment">/**
* Parse the xmlrpc response contained in the string data and return an xmlrpcresp object.
* <span class="attrib">@param</span> {string} data the xmlrpc response, eventually including http headers
* <span class="attrib">@param</span> {boolean|string} headers_processed When true prevents parsing HTTP headers for interpretation of content-encoding and consequent decoding. If a string, it is assumed to be the complete set of http headers, separated from response body. Defaults to false
* <span class="attrib">@param</span> {string} return_type decides return type, i.e. content of response.value(). Either 'xmlrpcvals' (default), 'xml' or 'jsvals'
* <span class="attrib">@type</span> xmlrpcresp
* <span class="attrib">@public</span>
*/</span>
xmlrpcmsg.<span class="reserved">prototype</span>.parseResponse = <span class="reserved">function</span> (data, headers_processed, return_type) {

<span class="comment">//alert(headers_processed);</span>
<span class="comment">//alert(data);</span>

	var headers = <span class="literal">''</span>;
	<span class="reserved">if</span> (headers_processed === undefined)
	{
		headers_processed = false;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (typeof(headers_processed) == <span class="literal">'string'</span>)
	{
		headers = headers_processed;
		headers_processed = true;
	}

	<span class="reserved">if</span> (return_type === undefined)
	{
		return_type = <span class="literal">'xmlrpcvals'</span>;
	}

	<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
	{
		xmlrpc_debug_log(<span class="literal">'&lt;PRE&gt;---GOT---\n'</span> + htmlentities(data) + <span class="literal">'\n---END---\n&lt;/PRE&gt;'</span>);
	}
	<span class="reserved">if</span> (data == <span class="literal">''</span>)
	{
		xmlrpc_error_log(<span class="literal">'XML-RPC: xmlrpcmsg::parseResponse: no response received from server.'</span>);
		var r = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'no_data'</span>], xmlrpcstr[<span class="literal">'no_data'</span>]);
		<span class="reserved">return</span> r;
	}

	_xh = {headers: [], cookies: {}};
	var raw_data = data;
	<span class="comment">// examining http headers: check first if given as second param to function</span>
	<span class="reserved">if</span> (headers != <span class="literal">''</span>)
	{
		var r = <span class="reserved">this</span>.parseResponseHeaders(headers, true);
	}
	<span class="comment">// else check if http headers given as part of complete html response</span>
	<span class="reserved">else</span> <span class="reserved">if</span> (data.slice(0, 4) == <span class="literal">'HTTP'</span>)
	{
		<span class="comment">// if it was so, remove them (or return an error response, if parsing fails)</span>
		var r = <span class="reserved">this</span>.ParseResponseHeaders(data, headers_processed);
		<span class="reserved">if</span> (typeof(r) !== <span class="literal">'string'</span>)
		{
			r.raw_data = data;
			<span class="reserved">return</span> r;
		}
		<span class="reserved">else</span>
		{
			data = r;
		}
	}

	<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
	{
		var start = data.indexOf(<span class="literal">'&lt;!-- SERVER DEBUG INFO (BASE64 ENCODED):'</span>);
		<span class="reserved">if</span> (start != -1)
		{
			start += 41; <span class="comment">//new String('&lt;!-- SERVER DEBUG INFO (BASE64 ENCODED):').length();</span>
			var end = data.indexOf(<span class="literal">'--&gt;'</span>, start);
			var comments = data.slice(start, end-1);
			xmlrpc_debug_log(<span class="literal">'&lt;PRE&gt;---SERVER DEBUG INFO (DECODED)---\n\t'</span>+htmlentities(base64_decode(comments).replace(/\n/g, <span class="literal">'\n\t'</span>))+<span class="literal">'\n---END---\n&lt;/PRE&gt;'</span>);
		}
	}

	<span class="comment">// be tolerant of extra whitespace in response body</span>
	data = data.replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>);

	<span class="comment">// be tolerant of junk after methodResponse (e.g. javascript ads automatically inserted by free hosts)</span>
	var pos = data.lastIndexOf(<span class="literal">'&lt;/methodResponse&gt;'</span>);
	<span class="reserved">if</span> (pos &gt;= 0)
	{
		data = data.slice(0, pos+17);
	}

	<span class="comment">// if user wants back raw xml, give it to him</span>
	<span class="reserved">if</span> (return_type == <span class="literal">'xml'</span>)
	{
		var r = new xmlrpcresp(data, 0, <span class="literal">''</span>, <span class="literal">'xml'</span>);
		r.hdrs = _xh[<span class="literal">'headers'</span>];
		r._cookies = _xh[<span class="literal">'cookies'</span>];
		r.raw_data = raw_data;
		<span class="reserved">return</span> r;
	}

	<span class="comment">/// <span class="attrib">@todo</span> try to 'guestimate' the character encoding of the received response</span>

	<span class="comment">// build xml parser object</span>
	var obj = null;
	var isMoz = false;
	var isIE = false;
	var isASV = false;

	try
	{ <span class="comment">//to get Adobe's SVG parseXML</span>
		obj = window.parseXML;
		<span class="reserved">if</span> (obj == null)
		{
			throw <span class="literal">'No ASV paseXML'</span>;
		}
		isASV = true;
	}
	catch(e)
	{
		try
		{ <span class="comment">//to get the mozilla parser</span>
			obj = new DOMParser();
			isMoz = true;
		}
		catch(e)
		{
			<span class="reserved">for</span>(var i = 0; i &lt; _msxmldoc_progid.length; ++i)
			{
				try
				{
					<span class="comment">// Instantiates XML parser for IE and assign to obj.</span>
					obj = new ActiveXObject(_msxmldoc_progid[i]);
					isIE = true;
					break;
				}
				catch(e) {}
			}
		}
	}
	<span class="reserved">if</span> (!isIE &amp;&amp; !isMoz &amp;&amp; !isASV)
	{
		var r = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'no_parser'</span>], xmlrpcstr[<span class="literal">'no_parser'</span>]);
		r.hdrs = _xh[<span class="literal">'headers'</span>];
		r._cookies = _xh[<span class="literal">'cookies'</span>];
		r.raw_data = raw_data;
		<span class="reserved">return</span> r;
	}

	try
	{
		<span class="reserved">if</span> (isMoz)
		{
			obj = obj.parseFromString(data, <span class="literal">'text/xml'</span>);
		}
		<span class="reserved">else</span> <span class="reserved">if</span> (isIE)
		{
			obj.loadXML(data);
		}
		<span class="reserved">else</span> <span class="reserved">if</span> (isASV)
		{
			obj = window.parseXML(data, null);
		}
	}
	catch(e)
	{
		<span class="comment">/// <span class="attrib">@todo</span> add some more error info here: check out exception obj...</span>
		xmlrpc_error_log(<span class="literal">'XML Error'</span>);
		<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
		{
			xmlrpc_debug_log(<span class="literal">'XML Error'</span>);
		}
		var r = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'invalid_return'</span>], xmlrpcstr[<span class="literal">'invalid_return'</span>]);
		r.hdrs = _xh[<span class="literal">'headers'</span>];
		r._cookies = _xh[<span class="literal">'cookies'</span>];
		r.raw_data = raw_data;
		<span class="reserved">return</span> r;
	}

	try
	{
		var node = obj.documentElement;
		<span class="reserved">if</span> (node == null)
		{<span class="comment">//just in case parse xml didn't throw an Exception but returned nothing usefull.</span>
			throw <span class="literal">'No documentElement found.'</span>;
		}
		switch(node.tagName)
		{
			case <span class="literal">'methodResponse'</span>:
				<span class="comment">//return parseMethodResponse(node);</span>
				node = getSingleChild(node, [<span class="literal">'params'</span>, <span class="literal">'fault'</span>]);
				<span class="reserved">if</span> (node.tagName == <span class="literal">'fault'</span>)
				{
					node = getSingleChild(node, [<span class="literal">'value'</span>]);
					var value = parseXmlrpcValue(node, true);
					<span class="comment">/// <span class="attrib">@todo</span> validate more format of error response: check for extra members...</span>
					<span class="reserved">if</span> (typeof(value) != <span class="literal">'object'</span> || !value.hasOwnProperty(<span class="literal">'faultCode'</span>) || !value.hasOwnProperty(<span class="literal">'faultString'</span>))
					{
						var r = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'invalid_return'</span>], xmlrpcstr[<span class="literal">'invalid_return'</span>]+ <span class="literal">' (malformed fault response)'</span>);
					}
					<span class="reserved">else</span>
					{
						<span class="reserved">if</span> (value[<span class="literal">'faultCode'</span>] == 0)
						{
							value[<span class="literal">'faultCode'</span>] = -1;
						}
						var r = new xmlrpcresp(0, value[<span class="literal">'faultCode'</span>], value[<span class="literal">'faultString'</span>]);
					}
				}
				<span class="reserved">else</span>
				{
					node = getSingleChild(node, [<span class="literal">'param'</span>]);
					node = getSingleChild(node, [<span class="literal">'value'</span>]);
					var value = parseXmlrpcValue(node, return_type == <span class="literal">'jsval'</span>);
					var r = new xmlrpcresp(value, 0, <span class="literal">''</span>, return_type);
				}
				<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
				{
					xmlrpc_debug_log(<span class="literal">'&lt;PRE&gt;---PARSED---'</span>);
					xmlrpc_debug_log(htmlentities(var_export(value)));
					xmlrpc_debug_log(<span class="literal">'\n---END---&lt;/PRE&gt;'</span>);
				}
				r.hdrs = _xh[<span class="literal">'headers'</span>];
				r._cookies = _xh[<span class="literal">'cookies'</span>];
				r.raw_data = raw_data;
				<span class="reserved">return</span> r;
			<span class="comment">//case "methodCall":</span>
			<span class="comment">//	return parseMethodCall(node);</span>
			default: <span class="comment">//nothing usefull returned by parseXML.</span>
				throw <span class="literal">'missing top level xmlrpc element'</span>;
		}
	}
	catch (e)
	{
		<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
		{
			<span class="comment">/// <span class="attrib">@todo</span> echo something for user?</span>
		}
		var r = new xmlrpcresp(0, xmlrpcerr[<span class="literal">'invalid_return'</span>], xmlrpcstr[<span class="literal">'invalid_return'</span>] + <span class="literal">' ('</span> + e.toString() + <span class="literal">')'</span>);
		r.hdrs = _xh[<span class="literal">'headers'</span>];
		r._cookies = _xh[<span class="literal">'cookies'</span>];
		r.raw_data = raw_data;
		<span class="reserved">return</span> r;
	}
}

<span class="comment">/******************************************************************************/</span>
<span class="comment">/**
* <span class="attrib">@param</span> {mixed} val either an xmlrpcval obj, a js value or the xml serialization of an xmlrpcval (a string)
* <span class="attrib">@param</span> {integer} fcode set it to anything but 0 to create an error response
* <span class="attrib">@param</span> {string} fstr the error string, in case of an error response
* <span class="attrib">@param</span> {string} valtyp either 'xmlrpcvals', 'jsvals' or 'xml'. When unspecified, the type of the val parameter is analyzed to best guess how to encode it (any js string will be assumed to be the xml representation of a response)
* <span class="attrib">@constructor</span>
*/</span>
<span class="reserved">function</span> xmlrpcresp(val, fcode, fstr, valtyp) {
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.val = 0;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.valtyp = <span class="literal">''</span>;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.errno = 0;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.errstr = <span class="literal">''</span>;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.payload = <span class="literal">''</span>;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.hdrs = [];
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>._cookies = {};
	<span class="comment">//this.content_type = 'text/xml';</span>
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.raw_data = <span class="literal">''</span>;

	<span class="reserved">this</span>.init(val, fcode, fstr, valtyp);
}

<span class="comment">/**
* Constructor for xmlrpcresp. Moved outside the xmlrpcresp() functions becuase we need subclasses to call it
* <span class="attrib">@private</span>
*
* <span class="attrib">@todo</span> add check that val / fcode / fstr is of correct type???
* NB: as of now we do not do it, since it might be either an xmlrpcval or a plain
* js val, or a complete xml chunk, depending on usage of xmlrpc_client::send() inside which creator is called...
*/</span>
xmlrpcresp.<span class="reserved">prototype</span>.init = <span class="reserved">function</span> (val, fcode, fstr, valtyp) {
	<span class="reserved">if</span> (fcode != undefined &amp;&amp; fcode != 0)
	{
		<span class="comment">// error response</span>
		<span class="reserved">this</span>.errno = fcode;
		<span class="reserved">this</span>.errstr = fstr;
		<span class="comment">//this.errstr = htmlspecialchars(fstr); // XXX: encoding probably shouldn't be done here; fix later.</span>
	}
	<span class="reserved">else</span>
	{
		<span class="comment">// successful response</span>
		<span class="reserved">this</span>.val = val;
		<span class="reserved">if</span> (valtyp == undefined)
		{
			<span class="comment">// user did not declare type of response value: try to guess it</span>
			<span class="comment">/// <span class="attrib">@todo</span>: verify class...</span>
			<span class="reserved">if</span> (typeof(val) == <span class="literal">'object'</span>) <span class="comment">//&amp;&amp; is_a(this.val, 'xmlrpcval'))</span>
			{
				<span class="reserved">this</span>.valtyp = <span class="literal">'xmlrpcvals'</span>;
			}
			<span class="reserved">else</span> <span class="reserved">if</span> (typeof(val) == <span class="literal">'string'</span>)
			{
				<span class="reserved">this</span>.valtyp = <span class="literal">'xml'</span>;
			}
			<span class="reserved">else</span>
			{
				<span class="reserved">this</span>.valtyp = <span class="literal">'jsvals'</span>;
			}
		}
		<span class="reserved">else</span>
		{
			<span class="comment">// user declares type of resp value: believe him</span>
			<span class="reserved">this</span>.valtyp = valtyp;
		}
	}
}

<span class="comment">/**
* Returns the error code of the response.
* <span class="attrib">@return</span> the error code of this response (0 for not-error responses)
* <span class="attrib">@type</span> integer
* <span class="attrib">@public</span>
*/</span>
xmlrpcresp.<span class="reserved">prototype</span>.faultCode = <span class="reserved">function</span> () {
	<span class="reserved">return</span> <span class="reserved">this</span>.errno;
}

<span class="comment">/**
* Returns the error string of the response.
* <span class="attrib">@return</span> the error string of this response ('' for not-error responses)
* <span class="attrib">@type</span> integer
* <span class="attrib">@public</span>
*/</span>
xmlrpcresp.<span class="reserved">prototype</span>.faultString = <span class="reserved">function</span> () {
	<span class="reserved">return</span> <span class="reserved">this</span>.errstr;
}

<span class="comment">/**
* Returns the value received by the server.
* <span class="attrib">@return</span> the xmlrpcval object returned by the server. Might be an xml string or js value if the response has been created by specially configured xmlrpc_client objects
* <span class="attrib">@type</span> mixed
* <span class="attrib">@public</span>
*/</span>
xmlrpcresp.<span class="reserved">prototype</span>.value = <span class="reserved">function</span> () {
	<span class="reserved">return</span> <span class="reserved">this</span>.val;
}

<span class="comment">/**
* Returns an array with the cookies received from the server.
* Array has the form: cookiename =&gt; array ('value' =&gt; val, attr1 =&gt; val1, attr2 = val2, ...)
* with attributes being e.g. 'expires', 'path', domain'.
* NB: cookies sent as 'expired' by the server (i.e. with an expiry date in the past)
* are still present in the array. It is up to the user-defined code to decide
* how to use the received cookies, and wheter they have to be sent back with the next
* request to the server (using xmlrpc_client::setCookie) or not
* <span class="attrib">@return</span> array of cookies received from the server
* <span class="attrib">@type</span> object
* <span class="attrib">@public</span>
*/</span>
xmlrpcresp.<span class="reserved">prototype</span>.cookies = <span class="reserved">function</span> () {
	<span class="reserved">return</span> <span class="reserved">this</span>._cookies;
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
xmlrpcresp.<span class="reserved">prototype</span>.xml_header = <span class="reserved">function</span> (charset_encoding) {
	<span class="reserved">if</span> (charset_encoding != undefined &amp;&amp; charset_encoding != <span class="literal">''</span>)
	{
		<span class="reserved">return</span> <span class="literal">'&lt;?xml version="1.0" encoding="'</span>+charset_encoding+<span class="literal">'" ?'</span> + <span class="literal">'&gt;\n&lt;methodResponse&gt;\n'</span>;
	}
	<span class="reserved">else</span>
	{
		<span class="reserved">return</span> <span class="literal">'&lt;?xml version="1.0"?'</span> + <span class="literal">'&gt;\n&lt;methodResponse&gt;\n'</span>;
	}
}

<span class="comment">/**
* Returns xml representation of the response. XML prologue not included
* <span class="attrib">@param</span> {string} charset_encoding the charset to be used for serialization. If null, US-ASCII is assumed
* <span class="attrib">@return</span> the xml representation of the response
* <span class="attrib">@type</span> string
* <span class="attrib">@public</span>
*/</span>
xmlrpcresp.<span class="reserved">prototype</span>.serialize = <span class="reserved">function</span> (charset_encoding) {
	<span class="comment">//if (charset_encoding != undefined &amp;&amp; charset_encoding != '')</span>
	<span class="comment">//	this.content_type = 'text/xml; charset=' + charset_encoding;</span>
	<span class="comment">//else</span>
	<span class="comment">//	this.content_type = 'text/xml';</span>
	result = <span class="reserved">this</span>.xml_header(charset_encoding);
	<span class="reserved">if</span> (<span class="reserved">this</span>.errno)
	{
		<span class="comment">// G. Giunta 2005/2/13: let non-ASCII response messages be tolerated by clients</span>
		<span class="comment">// by xml-encoding non ascii chars</span>
		result += <span class="literal">'&lt;fault&gt;\n'</span> +
<span class="literal">'&lt;value&gt;\n&lt;struct&gt;&lt;member&gt;&lt;name&gt;faultCode&lt;/name&gt;\n&lt;value&gt;&lt;int&gt;'</span> + <span class="reserved">this</span>.errno +
<span class="literal">'&lt;/int&gt;&lt;/value&gt;\n&lt;/member&gt;\n&lt;member&gt;\n&lt;name&gt;faultString&lt;/name&gt;\n&lt;value&gt;&lt;string&gt;'</span> +
<span class="comment">//xmlrpc_encode_entities(this.errstr, GLOBALS['xmlrpc_internalencoding'], charset_encoding) + "&lt;/string&gt;&lt;/value&gt;\n&lt;/member&gt;\n" +</span>
xmlrpc_encode_entities(<span class="reserved">this</span>.errstr) + <span class="literal">'&lt;/string&gt;&lt;/value&gt;\n&lt;/member&gt;\n'</span> +
<span class="literal">'&lt;/struct&gt;\n&lt;/value&gt;\n&lt;/fault&gt;'</span>;
	}
	<span class="reserved">else</span>
	{
		<span class="comment">/// <span class="attrib">@todo</span> test for correct obj class</span>
		<span class="reserved">if</span> (typeof(<span class="reserved">this</span>.val) != <span class="literal">'object'</span>) <span class="comment">// || !is_a(this.val, 'xmlrpcval'))</span>
		{
			<span class="reserved">if</span> (typeof(<span class="reserved">this</span>.val) == <span class="literal">'string'</span> &amp;&amp; <span class="reserved">this</span>.valtyp == <span class="literal">'xml'</span>)
			{
				result += <span class="literal">'&lt;params&gt;\n&lt;param&gt;\n'</span> +
					<span class="reserved">this</span>.val +
					<span class="literal">'&lt;/param&gt;\n&lt;/params&gt;'</span>;
			}
			<span class="reserved">else</span>
			{
				<span class="comment">/// <span class="attrib">@todo</span> try to build something serializable?</span>
				<span class="comment">///die('cannot serialize xmlrpcresp objects whose content is native js values');</span>
			}
		}
		<span class="reserved">else</span>
		{
			result += <span class="literal">'&lt;params&gt;\n&lt;param&gt;\n'</span> +
				<span class="reserved">this</span>.val.serialize(charset_encoding) +
				<span class="literal">'&lt;/param&gt;\n&lt;/params&gt;'</span>;
		}
	}
	result += <span class="literal">'\n&lt;/methodResponse&gt;'</span>;
	<span class="reserved">this</span>.payload = result;
	<span class="reserved">return</span> result;
}

<span class="comment">/******************************************************************************/</span>

<span class="comment">/**
* Takes an xmlrpc value in xmlrpcval object format and translates it into native javascript types.
* Works with xmlrpc message objects as input, too.
* <span class="attrib">@param</span> {xmlrpcval} xmlrpc_val
* <span class="attrib">@param</span> {object} not in use (yet)
* <span class="attrib">@type</span> mixed
* <span class="attrib">@public</span>
*
* <span class="attrib">@todo</span> add support for rebuilding non-anon js objects
*/</span>
<span class="reserved">function</span> xmlrpc_decode(xmlrpc_val, options) {
	switch(xmlrpc_val.kindOf())
	{
		case <span class="literal">'scalar'</span>:
			<span class="reserved">return</span> xmlrpc_val.scalarVal();
		case <span class="literal">'array'</span>:
			var size = xmlrpc_val.arraySize();
			var arr = [];
			<span class="reserved">for</span>(var i = 0; i &lt; size; ++i)
			{
				arr[arr.length] = xmlrpc_decode(xmlrpc_val.arrayMem(i), options);
			}
			<span class="reserved">return</span> arr;
		case <span class="literal">'struct'</span>:
			<span class="comment">// If user said so, try to rebuild js objects for specific struct vals.</span>
			<span class="comment">/// <span class="attrib">@todo</span> should we raise a warning for class not found?</span>
			<span class="comment">// shall we check for proper subclass of xmlrpcval instead of</span>
			<span class="comment">// presence of _php_class to detect what we can do?</span>
			<span class="reserved">if</span> ((options != undefined &amp;&amp; options[<span class="literal">'decode_js_objs'</span>]) &amp;&amp; xmlrpc_val._js_class != <span class="literal">''</span>)
				<span class="comment">//&amp;&amp; class_exists($xmlrpc_val-&gt;_php_class)) /// <span class="attrib">@todo</span> check if a class exists with given name</span>
			{
				var obj = new xmlrpc_val._js_class;
			}
			<span class="reserved">else</span>
			{
				var obj = {};
			}
			<span class="reserved">for</span>(var key in xmlrpcval.me)
			{
				obj[key] = xmlrpc_decode(xmlrpc_val.me[key], options);
			}
			<span class="reserved">return</span> obj;
		case <span class="literal">'msg'</span>:
			var paramcount = xmlrpc_val.getNumParams();
			var arr = [];
			<span class="reserved">for</span>(var i = 0; i &lt; paramcount; ++i)
			{
				arr[arr.lenght] = xmlrpc_decode(xmlrpc_val.getParam(i));
			}
			<span class="reserved">return</span> arr;
		}
}

<span class="comment">/**
* Takes native javascript types and encodes them recursively into xmlrpcval object format.
* It will not re-encode xmlrpcval objects (ie. they can be freely mixed with native js values).
* <span class="attrib">@param</span> {mixed} js_val The value to be converted into an xmlrpcval object
* <span class="attrib">@param</span> {array} options
* <span class="attrib">@type</span> xmlrpcval
* <span class="attrib">@public</span>
*/</span>
<span class="reserved">function</span> xmlrpc_encode(js_val, options) {
	var type = typeof js_val;
	switch(type)
	{
		case <span class="literal">'string'</span>:
			<span class="reserved">if</span> ((options != undefined &amp;&amp; options[<span class="literal">'auto_dates'</span>]) &amp;&amp; js_val.search(/^[0-9]{8}T[0-9]{2}:[0-9]{2}:[0-9]{2}$/) != -1)
				var xmlrpc_val = new xmlrpcval(js_val, <span class="literal">'dateTime.iso8601'</span>);
			<span class="reserved">else</span>
				var xmlrpc_val = new xmlrpcval(js_val, <span class="literal">'string'</span>);
			break;
		case <span class="literal">'number'</span>:
			<span class="comment">/// <span class="attrib">@todo</span>...</span>
			var num = new Number(js_val);
			<span class="reserved">if</span> (num == parseInt(num))
			{
				var xmlrpc_val = new xmlrpcval(js_val, <span class="literal">'int'</span>);
			}
			<span class="reserved">else</span> <span class="comment">//if (num == parseFloat(num))</span>
			{
				var xmlrpc_val = new xmlrpcval(js_val, <span class="literal">'double'</span>);
			}
			<span class="comment">//else</span>
			<span class="comment">//{</span>
				<span class="comment">// ??? only NaN and Infinity can get here. Encode them as zero (double)...</span>
			<span class="comment">//	var xmlrpc_val = new xmlrpcval(0, 'double');</span>
			<span class="comment">//}</span>
			break;
		case <span class="literal">'boolean'</span>:
			var xmlrpc_val = new xmlrpcval(js_val, <span class="literal">'boolean'</span>);
			break;
		case <span class="literal">'object'</span>:
			<span class="comment">// we should be able to use js_val instanceof Null, but FF refuses it...</span>
			<span class="comment">// nb: check nulls first, since they have no attributes</span>
			<span class="reserved">if</span> (js_val === null)
			{
				<span class="reserved">if</span> (options != undefined &amp;&amp; options[<span class="literal">'null_extension'</span>])
				{
					var xmlrpc_val = new xmlrpcval(null, <span class="literal">'null'</span>);
				}
				<span class="reserved">else</span>
				{
					var xmlrpc_val = new xmlrpcval();
				}
			}
			<span class="reserved">else</span>
			<span class="reserved">if</span> (js_val.toXmlRpcVal)
			{
				var xmlrpc_val = js_val.toXmlRpcVal();
			}
			<span class="reserved">else</span>
			<span class="reserved">if</span> (js_val instanceof Array)
			{
				var arr = [];
					<span class="reserved">for</span>(var i = 0; i &lt; js_val.length; ++i)
					{
						arr[arr.length] = xmlrpc_encode(js_val[i], options);
					}
					var xmlrpc_val = new xmlrpcval(arr, <span class="literal">'array'</span>);
			}
			<span class="reserved">else</span>
			<span class="comment">// xmlrpcval acquired capability to do this on its own, declaring toXmlRpcVal()</span>
			<span class="comment">//if (js_val instanceof xmlrpcval)</span>
			<span class="comment">//{</span>
			<span class="comment">//	var xmlrpc_val = js_val;</span>
			<span class="comment">//}</span>
			<span class="comment">//else</span>
			{
				<span class="comment">// generic js object. encode all members except functions</span>
				var arr = {};
				<span class="reserved">for</span>(var attr in js_val)
				{
					<span class="reserved">if</span> (typeof js_val[attr] != <span class="literal">'function'</span>)
					{
						arr[attr] = xmlrpc_encode(js_val[attr], options);
					}
				}
				var xmlrpc_val = new xmlrpcval(arr, <span class="literal">'struct'</span>);
				<span class="comment">/*if (in_array('encode_php_objs', options))
				{
					// let's save original class name into xmlrpcval:
					// might be useful later on...
					$xmlrpc_val._php_class = get_class($php_val);
				}*/</span>
			}
			break;
		<span class="comment">// match 'function', 'undefined', ...</span>
		default:
			<span class="comment">// it has to return an empty object in case</span>
			var xmlrpc_val = new xmlrpcval();
			break;
		}
		<span class="reserved">return</span> xmlrpc_val;
}

<span class="comment">/**
* !!! TO BE IMPLEMENTED !!!
* Convert the xml representation of a method response, method request or single
* xmlrpc value into the appropriate object (deserialize)
* <span class="attrib">@param</span> {string} xml_val
* <span class="attrib">@param</span> {array} options
* <span class="attrib">@return</span> false on error, or an instance of either xmlrpcval, xmlrpcmsg or xmlrpcresp
* <span class="attrib">@type</span> mixed
* <span class="attrib">@public</span>
*/</span>
<span class="reserved">function</span> xmlrpc_decode_xml(xml_val, options) {

}

<span class="comment">/******************************************************************************/</span>
<span class="comment">// helper functions (from phpxmlrpc)...</span>

<span class="comment">/**
* Decodes a Base64 encoded string to a byte string.
* <span class="attrib">@param</span> {string} aString
* <span class="attrib">@type</span> string
* <span class="attrib">@throws</span> exception can be raised when decoding improperly coded data
* <span class="attrib">@public</span>
*/</span>
<span class="reserved">function</span> base64_decode (aString) {
	<span class="reserved">if</span> ((aString.length % 4) == 0)
	{
		<span class="reserved">if</span> (typeof atob == <span class="literal">'function'</span>)
		{ <span class="comment">//try using mozillas builtin codec</span>
			<span class="reserved">return</span> atob(aString);
		}
		<span class="reserved">else</span>
		{
			<span class="reserved">if</span> (aString == <span class="literal">''</span>)
				<span class="reserved">return</span> <span class="literal">''</span>;
			var nBits;
			<span class="comment">// create a result buffer, this is much faster than having strings concatenated.</span>
			var sDecoded = [aString.length / 4];
			var base64 = <span class="literal">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='</span>;
			<span class="reserved">for</span>(var i = 0; i &lt; aString.length; i += 4)
			{
				nBits = (base64.indexOf(aString.charAt(i)) &amp; 0xff) &lt;&lt; 18 |
					(base64.indexOf(aString.charAt(i+1)) &amp; 0xff) &lt;&lt; 12 |
					(base64.indexOf(aString.charAt(i+2)) &amp; 0xff) &lt;&lt; 6 |
					base64.indexOf(aString.charAt(i+3)) &amp; 0xff;
				sDecoded[i] = String.fromCharCode((nBits &amp; 0xff0000) &gt;&gt; 16, (nBits &amp; 0xff00) &gt;&gt; 8, nBits &amp; 0xff);
			}
			<span class="comment">//make sure padding chars are left out.</span>
			sDecoded[sDecoded.length-1] = sDecoded[sDecoded.length-1].substring(0, 3 - ((aString.charCodeAt(i - 2) == 61) ? 2 : (aString.charCodeAt(i - 1) == 61 ? 1 : 0)));
			<span class="reserved">return</span> sDecoded.join(<span class="literal">''</span>);
		}
	}
	<span class="reserved">else</span>
	{
		<span class="comment">//throw new mod.Exception("String length must be divisible by 4.");</span>
		<span class="reserved">return</span> null;
	}
}

<span class="comment">/**
* Encodes a string using Base64.
* <span class="attrib">@param</span> {string} aString
* <span class="attrib">@type</span> string
* <span class="attrib">@public</span>
* <span class="attrib">@bug</span> given an empty string, returns '0' in IE and Opera
*/</span>
<span class="reserved">function</span> base64_encode (aString) {
	<span class="reserved">if</span> (typeof btoa == <span class="literal">'function'</span>)
	{ <span class="comment">// try using mozillas builtin codec</span>
		<span class="reserved">return</span> btoa(aString);
	}
	<span class="reserved">else</span>
	{
		var base64 = [<span class="literal">'A'</span>,<span class="literal">'B'</span>,<span class="literal">'C'</span>,<span class="literal">'D'</span>,<span class="literal">'E'</span>,<span class="literal">'F'</span>,<span class="literal">'G'</span>,<span class="literal">'H'</span>,<span class="literal">'I'</span>,<span class="literal">'J'</span>,<span class="literal">'K'</span>,<span class="literal">'L'</span>,<span class="literal">'M'</span>,<span class="literal">'N'</span>,<span class="literal">'O'</span>,<span class="literal">'P'</span>,<span class="literal">'Q'</span>,<span class="literal">'R'</span>,<span class="literal">'S'</span>,<span class="literal">'T'</span>,<span class="literal">'U'</span>,<span class="literal">'V'</span>,<span class="literal">'W'</span>,<span class="literal">'X'</span>,<span class="literal">'Y'</span>,<span class="literal">'Z'</span>,
					  <span class="literal">'a'</span>,<span class="literal">'b'</span>,<span class="literal">'c'</span>,<span class="literal">'d'</span>,<span class="literal">'e'</span>,<span class="literal">'f'</span>,<span class="literal">'g'</span>,<span class="literal">'h'</span>,<span class="literal">'i'</span>,<span class="literal">'j'</span>,<span class="literal">'k'</span>,<span class="literal">'l'</span>,<span class="literal">'m'</span>,<span class="literal">'n'</span>,<span class="literal">'o'</span>,<span class="literal">'p'</span>,<span class="literal">'q'</span>,<span class="literal">'r'</span>,<span class="literal">'s'</span>,<span class="literal">'t'</span>,<span class="literal">'u'</span>,<span class="literal">'v'</span>,<span class="literal">'w'</span>,<span class="literal">'x'</span>,<span class="literal">'y'</span>,<span class="literal">'z'</span>,
					  <span class="literal">'0'</span>,<span class="literal">'1'</span>,<span class="literal">'2'</span>,<span class="literal">'3'</span>,<span class="literal">'4'</span>,<span class="literal">'5'</span>,<span class="literal">'6'</span>,<span class="literal">'7'</span>,<span class="literal">'8'</span>,<span class="literal">'9'</span>,<span class="literal">'+'</span>,<span class="literal">'/'</span>];
		var sbin;
		var pad = 0;
		var s = <span class="literal">''</span> + aString;
		<span class="reserved">if</span> ((s.length % 3) == 1)
		{
			s += String.fromCharCode(0);
			s += String.fromCharCode(0);
			pad = 2;
		}
		<span class="reserved">else</span> <span class="reserved">if</span> ((s.length % 3) == 2)
		{
			s += String.fromCharCode(0);
			pad = 1 ;
		}
		<span class="comment">//create a result buffer, this is much faster than having strings concatinated.</span>
		var rslt = [s.length / 3];
		var ri = 0;
		<span class="reserved">for</span>(var i = 0; i &lt; s.length; i += 3)
		{
			sbin = ((s.charCodeAt(i) &amp; 0xff) &lt;&lt; 16) | ((s.charCodeAt(i+1) &amp; 0xff) &lt;&lt; 8) | (s.charCodeAt(i+2) &amp; 0xff);
			rslt[ri] = (base64[(sbin &gt;&gt; 18) &amp; 0x3f] + base64[(sbin &gt;&gt; 12) &amp; 0x3f] + base64[(sbin &gt;&gt;6) &amp; 0x3f] + base64[sbin &amp; 0x3f]);
			ri++;
		}
		<span class="reserved">if</span> (pad &gt; 0)
		{
			rslt[rslt.length-1] = rslt[rslt.length-1].substr(0, 4-pad) +((pad==2) ? <span class="literal">'=='</span> : (pad==1) ? <span class="literal">'='</span> : <span class="literal">''</span>);
		}
		<span class="reserved">return</span> rslt.join(<span class="literal">''</span>);
	}
}

<span class="comment">/**
* Given a Date object, returns its representation in the iso8601 format used by xmlrpc
* <span class="attrib">@param</span> {Date} time
* <span class="attrib">@param</span> {boolean} utc when True, the UTC timezone is assumed
* <span class="attrib">@type</span> string
* <span class="attrib">@public</span>
*/</span>
<span class="reserved">function</span> iso8601_encode(time, utc) {
	var padd = <span class="reserved">function</span>(s, p)
	{
		s = p + s;
		<span class="reserved">return</span> s.substring(s.length - p.length);
	}
	<span class="reserved">if</span> (utc)
	{
		var y = padd(time.getUTCFullYear(), <span class="literal">"0000"</span>);
		var m = padd(time.getUTCMonth() + 1, <span class="literal">"00"</span>);
		var d = padd(time.getUTCDate(), <span class="literal">"00"</span>);
		var h = padd(time.getUTCHours(), <span class="literal">"00"</span>);
		var min = padd(time.getUTCMinutes(), <span class="literal">"00"</span>);
		var s = padd(time.getUTCSeconds(), <span class="literal">"00"</span>);
	}
	<span class="reserved">else</span>
	{
		var y = padd(time.getFullYear(), <span class="literal">"0000"</span>);
		var m = padd(time.getMonth() + 1, <span class="literal">"00"</span>);
		var d = padd(time.getDate(), <span class="literal">"00"</span>);
		var h = padd(time.getHours(), <span class="literal">"00"</span>);
		var min = padd(time.getMinutes(), <span class="literal">"00"</span>);
		var sec = padd(time.getSeconds(), <span class="literal">"00"</span>);
	}

	<span class="reserved">return</span> y + m + d + <span class="literal">"T"</span> + h + <span class="literal">":"</span> + min + <span class="literal">":"</span> + sec;
}

<span class="comment">/**
* Given an ISO8601 date string, return a date obj in the localtime, or UTC
* <span class="attrib">@param</span> {string} time
* <span class="attrib">@param</span> {boolean} utc
* <span class="attrib">@type</span> Date
* <span class="attrib">@public</span>
*/</span>
<span class="reserved">function</span> iso8601_decode(time, utc) {
	<span class="reserved">if</span> (/^(\d{4})(\d{2})(\d{2})T(\d{2}):(\d{2}):(\d{2})$/.test(time))
	{
		<span class="reserved">if</span> (utc)
			<span class="reserved">return</span> new Date(Date.UTC(RegExp.$1, RegExp.$2-1, RegExp.$3, RegExp.$4, RegExp.$5, RegExp.$6));
		<span class="reserved">else</span>
			<span class="reserved">return</span> new Date(RegExp.$1, RegExp.$2-1, RegExp.$3, RegExp.$4, RegExp.$5, RegExp.$6);
	}
	<span class="reserved">else</span>
		<span class="reserved">return</span> null;
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
<span class="reserved">function</span> xmlrpc_encode_entities(data, src_encoding, dest_encoding)
{
	<span class="reserved">return</span> new String(data).replace(/&amp;/g, <span class="literal">'&amp;amp;'</span>).replace(/&lt;/g, <span class="literal">'&amp;lt;'</span>).replace(/&gt;/g, <span class="literal">'&amp;gt;'</span>).replace(/<span class="literal">"/g, '&amp;quot;').replace(/'/g, '&amp;apos;');
	//return data.replace(/&amp;/g, "</span>&amp;amp;<span class="literal">").replace(/&lt;/g, "</span>&amp;lt;<span class="literal">");
}

/******************************************************************************/

/**
* @type xmlrpcval
* @private
*/
String.prototype.toXmlRpcVal = function(options) {
	return new xmlrpcval(this.toString());
}

/**
* @type xmlrpcval
* @todo: see if there are faster checks than parseInt and parseFloat
* @private
*/
Number.prototype.toXmlRpcVal = function(options) {
	if (this == parseInt(this))
	{
		return new xmlrpcval(this.valueOf(), 'int');
	}
	else //if (this == parseFloat(this))
	{
		return new xmlrpcval(this.valueOf(), 'double');
	}
	//else
	//{
		// ??? only NaN and Infinity can get here. Encode them as zero (double)...
	//	return new xmlrpcval(0, 'double');
	//}
}

/**
* @type xmlrpcval
* @private
*/
Boolean.prototype.toXmlRpcVal = function(options){
	return new xmlrpcval(this.valueOf(), 'boolean');
}

/**
* @type xmlrpcval
* @private
*/
Date.prototype.toXmlRpcVal = function(options) {
	return new xmlrpcval(iso8601_encode(this), 'dateTime.iso8601');
}

/**
 * Used to parse xml nodes: retrieve the single child if it is of correct type.
 * Raise an error on any other condition
 * @return an xml node
 * @throws string
 * @private
 **/
function getSingleChild(node, expectedType)
{
	var k;
	var ret = null;
	var child;
//alert('Looking for ' + expectedType[0])
	for(var i = 0, j = 0; i &lt; node.childNodes.length; i++)
	{
		child = node.childNodes.item(i);
		if (child.nodeType == 1) // ignore comments (8), character data (3), ...
		{
			for (k = 0; k &lt; expectedType.length; k++)
			{
				if (child.tagName == expectedType[k])
				{
				//alert('Found correct element inside ' + node.tagName + ': ' + child.tagName)
					ret = child;
					break;
				}
			}
			if (ret === null)
			{
				throw 'Found incorrect element inside ' + node.tagName + ': ' + child.tagName;
			}
			if (++j &gt; 1)
			{
				throw 'Found too many elements inside ' + node.tagName;
			}
		}
	}
	if (j == 0)
	{
		throw 'Found no element inside ' + node.tagName;
	}
	return ret;
}

/**
 * Used to parse xml nodes: retrieve the node text and checks that no sub-elemnts are present.
 * Raise an error on any other condition
 * @type string
 * @throws string
 * @private
 **/
function getChildText(node)
{
	var ret = '';
	for(var i = 0; i &lt; node.childNodes.length; i++)
	{
		child = node.childNodes.item(i);
		if (child.nodeType == 3) // ignore comments (8), character data (3), ...
		{
			ret += String(child.nodeValue)
		}
		else if (child.nodeType == 1) // ignore comments (8), character data (3), ...
		{
			throw 'elements found inside a '+node.tagName;
		}
	}
	return ret;
}

/**
 * @private
 **/
function parseXmlrpcValue(node, return_jsvals)
{
	if (return_jsvals === undefined)
	{
		return_jsvals = false;
	}
	/// @todo ...
	var s = '';
	var ret = null;
	var child;
	var valtyp;
	for(var i = 0, j = 0; i &lt; node.childNodes.length; i++)
	{
		child = node.childNodes.item(i);
		if (child.nodeType == 1) // ignore comments (8), character data (3), ...
		{
			valtyp = child.tagName;
			switch (child.tagName)
			{
				case 'string':
//xmlrpc_debug_log('found a string');
					ret = getChildText(child);
					break;
				case 'int':
				case 'i4':
					ret = getChildText(child);
					// we have an I4/INT
					// we must check that only 0123456789-&lt;space&gt; are characters here
					/// @todo use a better regexp than this (or remove it altogether)
					if (ret.search(/^[+-]?[0123456789 \t]+$/) == -1)
					{
						/// @todo find a better way of throwing an error
						// than this!
						xmlrpc_error_log('XML-RPC: non numeric value received in INT: ' + ret);
						ret = 'ERROR_NON_NUMERIC_FOUND';
					}
					else
					{
						// it's ok, add it on
						ret = parseInt(ret);
					}
					break;
				case 'double':
					// we have a DOUBLE
					// we must check that only 0123456789-.&lt;space&gt; are characters here
					ret = getChildText(child);
					/// @todo use a better regexp than this (or remove it altogether)
					if (ret.search(/^[+-]?[eE0123456789 \t.]+$/) == -1)
					{
						/// @todo: find a better way of throwing an error
						// than this!
						xmlrpc_error_log('XML-RPC: non numeric value received in DOUBLE: ' + ret);
						ret = 'ERROR_NON_NUMERIC_FOUND';
					}
					else
					{
						// it's ok, add it on
						ret = parseFloat(ret);
					}
					break;
				case 'boolean':
					ret = getChildText(child);
					if (ret == '1' || ret.search(/^true$/i) != -1)
					{
						ret = true;
					}
					else
					{
						// log if receiveing something strange, even though we set the value to false anyway
						if (ret != '0' &amp;&amp; ret.search(/^false$/i) == -1)
							xmlrpc_error_log('XML-RPC: invalid value received in BOOLEAN: ' + ret);
						ret = false;
					}
					break;
				case 'base64':
					/// @todo use a regexp to validate base64 encoded data?
					ret = base64_decode(getChildText(child));
					break;
				case 'dateTime.iso8601':
					ret = getChildText(child);
					if (ret.search(/^[0-9]{8}T[0-9]{2}:[0-9]{2}:[0-9]{2}$/) == -1)
					{
						xmlrpc_error_log('XML-RPC: invalid value received in DATETIME: ' + ret);
					}
					break;
				case 'array':
//xmlrpc_debug_log('found an array');
					child = getSingleChild(child, ['data']);
					ret = [];
					for (var k =0; k &lt; child.childNodes.length; k ++)
					{
						if (child.childNodes[k].nodeType == 1)
						{
							if (child.childNodes[k].tagName != 'value')
							{
								throw 'invalid element found inside array: '+ child.childNodes[k].tagName;
							}
							ret[ret.length] = parseXmlrpcValue(child.childNodes[k], return_jsvals);
						}
					}
					break;
				case 'struct':
//xmlrpc_debug_log('found a struct');
					ret = {};
					var membername, member, memberval;
					for (var k =0; k &lt; child.childNodes.length; ++k)
					{
						if (child.childNodes[k].nodeType == 1)
						{
							if (child.childNodes[k].tagName != 'member')
							{
								throw 'invalid element found inside struct: '+ child.childNodes[k].tagName;
							}
							member = child.childNodes[k];
							membername = ''; // struct members without a name will get named '' instead of rejected...
							memberval = undefined;
							for (var l =0; l &lt; member.childNodes.length; ++l)
							{
								if (member.childNodes[l].nodeType == 1)
								{
									switch(member.childNodes[l].tagName)
									{
										case 'name':
											membername = getChildText(member.childNodes[l]);
											break;
										case 'value':
											memberval = parseXmlrpcValue(member.childNodes[l], return_jsvals);
											break;
										default:
											throw 'invalid element found inside struct: '+ member.childNodes[l].tagName;
									}
								}
							}
							if (memberval === undefined)
								throw 'invalid member found inside struct: missing value';
							ret[membername] = memberval;
						}
					}
					break;
				default:
					throw 'Found incorrect element inside \'value\' :'+ child.tagName;

			}

			if (++j &gt; 1)
			{
				throw 'Found too many elements inside ' + node.tagName;
			}
		}
		else if (child.nodeType == 3)
		{
			s += new String(child.nodeValue);
		}
	}

	if (j == 0)
	{
		if (!return_jsvals)
		{
			return new xmlrpcval(s);
		}
		else
		{
			return s;
		}
	}
	else
	{
		if (!return_jsvals)
		{
			return new xmlrpcval(ret, valtyp);
		}
		else
		{
			return ret;
		}
	}
}

/**
* Function used to send an error message to the log. To override the default
* log handler, define the function 'xmlrpc_error_log_handler(string logmsg)'
* @public
* @type void
*/
function xmlrpc_error_log(errormsg) {
	if (typeof(xmlrpc_error_log_handler) != 'function')
	{
		// be smart with Firebug console
		if (window.console &amp;&amp; typeof window.console.error == 'function')
			window.console.error(logmsg);
		else
			//alert(errormsg);
			window.setTimeout(function(){throw new Error(errormsg);}, 0);
	}
	else
	{
		xmlrpc_error_log_handler(errormsg);
	}
}

/**
* Function used to send a debug message to the log. To override the default
* log handler, define the function 'xmlrpc_debug_log_handler(string logmsg)'
* @param {string} logmsg
* @type void
* @public
*/
function xmlrpc_debug_log(logmsg) {
	if (typeof(xmlrpc_debug_log_handler) != 'function')
	{
		// be smart with Firebug console
		if (window.console &amp;&amp; typeof window.console.debug == 'function')
			window.console.debug(logmsg);
		// and cater for Safari console, too
		//else if (window.console &amp;&amp; typeof window.console.log == 'function')
		//	window.console.log(logmsg);
		else
		{
			// document.writeln gives too many troubles, esp. w. firefox
			//document.writeln(logmsg);
			var el = document.createElement('pre');
			el.innerHTML = logmsg;
			document.body.appendChild(el);
		}
	}
	else
	{
		xmlrpc_debug_log_handler(logmsg);
	}
}

/**
* Debug helper. Should do the same as the PHP htmlentites function (well, htmlspecialchars rather...)
* @param {string} val
* @type string
* @todo encode all chars outside ASCII to html charset entity...
*/
function htmlentities(val, quote_style) {
	var out = new String(val).replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;');
	if (quote_style != 0)
		out = out.replace(/"</span>/g, <span class="literal">'&amp;quot;'</span>).replace(/<span class="literal">'/g, '</span>&amp;apos;<span class="literal">');
	return out;
}

/**
* Debug helper. Mimics PHP var_export function
* @param {mixed} val
* @param {boolean} ret
* @param {boolean} whitespaces
* @type string
*/
function var_export(val, ret, whitespaces) {
	var type = typeof val;
	var indent = '</span><span class="literal">';
	if (whitespaces !== undefined)
	{
		for (var i = 0; i &lt; whitespaces; i++)
			indent += '</span>  <span class="literal">';
	}
	else
	{
		whitespaces = 0;
	}
	switch(type)
	{
		case '</span>string<span class="literal">':
			return '</span>\<span class="literal">''</span> + val.replace(/<span class="literal">'/g, '</span>\<span class="literal">'\'</span><span class="literal">') + '</span>\<span class="literal">''</span>;
		case <span class="literal">'number'</span>:
		case <span class="literal">'boolean'</span>:
			<span class="reserved">return</span> val.toString();
		case <span class="literal">'object'</span>:
			<span class="comment">// we should be able to use val instanceof Null, but FF refuses it...</span>
			<span class="comment">// nb: check nulls first, since they have no attributes</span>
			<span class="reserved">if</span> (val === null)
			{
				<span class="reserved">return</span> <span class="literal">'null'</span>;
			}
			<span class="reserved">else</span> <span class="reserved">if</span> (val instanceof Array)
			{
				var arr = <span class="literal">'[\n'</span>;
				<span class="reserved">for</span>(var i = 0; i &lt; val.length; ++i)
				{
					arr += indent + <span class="literal">'  '</span> + var_export(val[i], ret, whitespaces+1) + <span class="literal">',\n'</span>;
				}
				arr += indent + <span class="literal">']'</span>;
				<span class="reserved">return</span> arr;
			}
			<span class="reserved">else</span>
			{
				<span class="comment">// generic js object. encode all members except functions</span>
				var arr = <span class="literal">'{\n'</span>;
				<span class="reserved">for</span>(var attr in val)
				{
					<span class="reserved">if</span> (typeof val[attr] != <span class="literal">'function'</span>)
					{
						arr += indent + <span class="literal">'  \'</span><span class="literal">' + attr + '</span>\<span class="literal">' =&gt; '</span> + var_export(val[attr], ret, whitespaces+1) + <span class="literal">',\n'</span>;
					}
				}
				arr += indent + <span class="literal">'}'</span>;
				<span class="reserved">return</span> arr;
			}
		<span class="comment">// match 'function', 'undefined', ...</span>
		default:
			<span class="reserved">return</span> indent + type;
	}
}</pre>
	<hr>



<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top"><em>
<b>js-xmlrpc</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<font size="-1">

</font>
<div class="jsdoc_ctime">Documentation generated by <a href="http://jsdoc.sourceforge.net/" target="_parent">JSDoc</a> on Tue Jun 26 14:36:04 2007</div>
</body>
</html>
