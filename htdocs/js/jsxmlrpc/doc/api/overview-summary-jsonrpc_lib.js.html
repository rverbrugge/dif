<!doctype html public "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<html>
<head>
<title>
js-xmlrpc Overview
</title>
<link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script>
function asd() {
	
		parent.document.title="jsonrpc_lib.js Overview";
	
}
</script>
</head>
<body bgcolor="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> 	<font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top">
<em>
<b>js-xmlrpc</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<center>
	
	   <h2>jsonrpc_lib.js</h2>
	
</center>

	


<h4>Summary</h4>
<p>
	
		No overview generated for 'jsonrpc_lib.js'<BR/><BR/>
	
</p>

<hr>


    <table border="1" cellpadding="3" cellspacing="0" width="100%">
    <tr bgcolor="#CCCCFF" class="TableHeadingColor">
    <td colspan=2><font size="+2">
    
        <b>Class Summary</b>
    
    </font></td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="jsonrpc_client.html">jsonrpc_client</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="jsonrpcmsg.html">jsonrpcmsg</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="jsonrpcresp.html">jsonrpcresp</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="jsonrpcval.html">jsonrpcval</a></b></td>
    <td>&nbsp;</td>
    </tr>
    
    </table>
    <hr/> 


<!-- ========== METHOD SUMMARY =========== -->

	<a name="method_summary"><!-- --></a>
	<table border="1" cellpadding="3" cellspacing="0" width="100%">
		<tr bgcolor="#CCCCFF" class="TableHeadingColor">
			<td colspan=2>
				<font size="+2">
					<b>Method Summary</b>
				</font>
			</td>
		</tr>
	
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;Object</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!jsonrpc_decode">jsonrpc_decode</a></b>(jsonrpc_val, options)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Takes a json value in jsonrpcval object format
 and translates it into native javascript types.
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;false | jsonrpcresp | jsonrpcmsg | jsonrpcval</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!jsonrpc_decode_json">jsonrpc_decode_json</a></b>(&lt;string&gt; json_val, &lt;object&gt; options)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Convert the json representation of a jsonrpc method call, jsonrpc method response
 or single json value into the appropriate object (deserialize)
		      </td>
		   </tr>
		
		   <tr bgcolor="white" class="TableRowColor">
		      <td align="right" valign="top" width="1%">
			 <font size="-1">
			    <code>static&nbsp;Object</code>
			 </font>
		      </td>
		      <td>
			 <code>
			    <b>
			       <a href="GLOBALS.html#!s!jsonrpc_encode">jsonrpc_encode</a></b>(js_val, options)
			 </code>
			 <br>
			 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			 Takes native javascript types and encodes them into jsonrpc object format.
		      </td>
		   </tr>
		
	
	</table>
    <p>

<!-- ========== END METHOD SUMMARY =========== -->


        <pre class="sourceview"><span class="comment">/**
* JS-XMLRPC: Yet Another JSONRPC Library, in Javascript!
*
* ...as if the world needed it...
*
* FOR COMPLETE API DOCS, READ PHP-XMLRPC API DOCS. THE SAME API (almost) IS IMPLEMENTED HERE!
*
* Many thanks to Jan-Klaas Kollhof for JSOLAIT, and to the Yahoo YUI team, for
* providing the building blocks for all of this
*
* <span class="attrib">@author</span> G. Giunta
* <span class="attrib">@version</span> $Id: jsonrpc_lib.js,v 1.8 2007/06/25 17:03:40 ggiunta Exp $
* <span class="attrib">@copyright</span> (c) 2006, 2007 G. Giunta
* <span class="attrib">@license</span> code licensed under the BSD License: http://phpxmlrpc.sourceforge.net/jsxmlrpc/license.txt
*
* KNOWN DIFFERENCES FROM PHP-XMLRPC:
* + jsonrpc_parse_resp() defaults to native parsing
*
* <span class="attrib">@todo</span> json parsing code in json_parse()
*/</span>

<span class="comment">// Requires: xmlrpc_lib.js</span>

<span class="comment">/**
* <span class="attrib">@private</span>
* <span class="attrib">@todo</span> add support for charset transcoding
*/</span>
<span class="reserved">function</span> json_encode_entities(data, src_encoding, dest_encoding)
{
    <span class="reserved">if</span> (data == undefined) <span class="comment">// catches case of data === null as well</span>
	{
    	<span class="reserved">return</span> <span class="literal">''</span>;
    }
	<span class="reserved">return</span> data.replace(<span class="literal">'\\'</span>, <span class="literal">'\\\\'</span>).replace(<span class="literal">'"'</span>, <span class="literal">'\\"'</span>).replace(<span class="literal">'/'</span>, <span class="literal">'\\/'</span>).replace(<span class="literal">'\t'</span>, <span class="literal">'\\t'</span>).replace(<span class="literal">'\n'</span>, <span class="literal">'\\n'</span>).replace(<span class="literal">'\r'</span>, <span class="literal">'\\r'</span>).replace(<span class="literal">'\b'</span>, <span class="literal">'\\b'</span>).replace(<span class="literal">'\v'</span>, <span class="literal">'\\v'</span>).replace(<span class="literal">'\f'</span>, <span class="literal">'\\f'</span>);
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
<span class="reserved">function</span> json_parse(data, return_jsvals, src_encoding, dest_encoding)
{
	<span class="reserved">if</span> (return_jsvals == undefined)
	{
		return_jsvals = false;
	}
	<span class="reserved">if</span> (src_encoding == undefined)
	{
		src_encoding = <span class="literal">'UTF-8'</span>;
	}
	<span class="reserved">if</span> (dest_encoding == undefined)
	{
		dest_encoding = <span class="literal">'ISO-8859-1'</span>;
	}

	_xh[<span class="literal">'isf_reason'</span>] = <span class="literal">'non-native JSON parsing not yet implemented.'</span>;
	<span class="reserved">return</span> false;
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
<span class="reserved">function</span> json_parse_native(data)
{
	<span class="comment">/// <span class="attrib">@todo</span> !!!VERY IMPORTANT!!! regexp to find out if it is valid json...</span>
	try
	{
		var out = eval(<span class="literal">'('</span> + data + <span class="literal">')'</span>);
		_xh[<span class="literal">'value'</span>] = out;
		<span class="reserved">return</span> true;
	}
	catch (e)
	{
		_xh[<span class="literal">'isf_reason'</span>] = <span class="literal">'JSON parsing failed'</span>;
		<span class="reserved">return</span> false;
	}
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
<span class="reserved">function</span> jsonrpc_parse_resp(data, return_jsvals, use_native_parsing)
{
	<span class="reserved">if</span> (return_jsvals == undefined)
	{
		return_jsvals = false;
	}
	<span class="reserved">if</span> (use_native_parsing == undefined)
	{
		use_native_parsing = true;
	}

	_xh[<span class="literal">'isf'</span>] = 0;
	_xh[<span class="literal">'isf_reason'</span>] = <span class="literal">''</span>;
	<span class="reserved">if</span> (use_native_parsing)
	{
		var ok = json_parse_native(data);
		<span class="comment">// we encode js vals to jsonrpcvals later, if needed</span>
		<span class="comment">//if (!return_jsvals)</span>
		<span class="comment">//{</span>
		<span class="comment">//	_xh['value'] = jsonrpc_encode(_xh['value']);</span>
		<span class="comment">//}</span>
	}
	<span class="reserved">else</span>
	{
		var ok = json_parse(data, return_jsvals);
	}
	<span class="reserved">if</span> (ok)
	{
		<span class="comment">//if (!return_jsvals)</span>
		<span class="comment">//{</span>
		<span class="comment">//	_xh['value'] = _xh['value'].me;</span>
		<span class="comment">//}</span>
		<span class="reserved">if</span> (typeof(_xh[<span class="literal">'value'</span>]) != <span class="literal">'object'</span> || _xh[<span class="literal">'value'</span>][<span class="literal">'result'</span>] === undefined
			|| _xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>] === undefined || _xh[<span class="literal">'value'</span>][<span class="literal">'id'</span>] === undefined)
		{
			<span class="comment">//_xh['isf'] = 2;</span>
			_xh[<span class="literal">'isf_reason'</span>] = <span class="literal">'JSON parsing did not return correct jsonrpc response object'</span>;
			<span class="reserved">return</span> false;
		}
		<span class="comment">//if (!return_jsvals)</span>
		<span class="comment">//{</span>
		<span class="comment">//	var d_error = jsonrpc_decode(_xh['value']['error']);</span>
		<span class="comment">//	_xh['value']['id'] = php_jsonrpc_decode(_xh['value']['id']);</span>
		<span class="comment">//}</span>
		<span class="comment">//else</span>
		<span class="comment">//{</span>
			var d_error = _xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>];
		<span class="comment">//}</span>
		_xh[<span class="literal">'id'</span>] = _xh[<span class="literal">'value'</span>][<span class="literal">'id'</span>];
		<span class="reserved">if</span> (d_error != null)
		{
			_xh[<span class="literal">'isf'</span>] = 1;
				<span class="comment">//_xh['value'] = $d_error;</span>
			<span class="reserved">if</span> (typeof(d_error) == <span class="literal">'object'</span> &amp;&amp; d_error[<span class="literal">'faultCode'</span>] !== undefined
				&amp;&amp; d_error[<span class="literal">'faultString'</span>] !== undefined)
			{
				<span class="reserved">if</span>(d_error[<span class="literal">'faultCode'</span>] == 0)
				{
					<span class="comment">// FAULT returned, errno needs to reflect that</span>
					d_error[<span class="literal">'faultCode'</span>] = -1;
				}
				_xh[<span class="literal">'value'</span>] = d_error;
			}
			<span class="comment">// NB: what about jsonrpc servers that do NOT respect</span>
			<span class="comment">// the faultCode/faultString convention???</span>
			<span class="comment">// we force the error into a string. regardless of type...</span>
			<span class="reserved">else</span> <span class="comment">//if (is_string(_xh['value']))</span>
			{
				<span class="reserved">if</span> (return_jsvals)
				{
					_xh[<span class="literal">'value'</span>] = {<span class="literal">'faultCode'</span>: -1, <span class="literal">'faultString'</span>: var_export(_xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>])};
				}
				<span class="reserved">else</span>
				{
					_xh[<span class="literal">'value'</span>] = {<span class="literal">'faultCode'</span>: -1, <span class="literal">'faultString'</span>: serialize_jsonrpcval(jsonrpc_encode(_xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>]))};
				}
			}
		}
		<span class="reserved">else</span>
		{
			<span class="reserved">if</span> (!return_jsvals)
				_xh[<span class="literal">'value'</span>] = jsonrpc_encode(_xh[<span class="literal">'value'</span>][<span class="literal">'result'</span>]);
			<span class="reserved">else</span>
				_xh[<span class="literal">'value'</span>] = _xh[<span class="literal">'value'</span>][<span class="literal">'result'</span>];
		}
		<span class="reserved">return</span> true;
	}
	<span class="reserved">else</span>
	{
		<span class="reserved">return</span> false;
	}
}

<span class="comment">/******************************************************************************/</span>
<span class="comment">/**
* <span class="attrib">@constructor</span>
**/</span>
<span class="reserved">function</span> jsonrpc_client(path, server, port, method)
{
	<span class="reserved">this</span>.no_multicall = true; <span class="comment">// by default, multicall is not supported in jsonrpc</span>
	<span class="reserved">this</span>.return_type = <span class="literal">'jsonrpcvals'</span>;

	<span class="reserved">this</span>.init(path, server, port, method);
}

jsonrpc_client.<span class="reserved">prototype</span> = new xmlrpc_client();

<span class="comment">/******************************************************************************/</span>
<span class="comment">/**
* <span class="attrib">@param</span> {string} meth Name of the method to be invoked
* <span class="attrib">@param</span> {array} pars list of parameters for method call (jsonrpcval objects)
* <span class="attrib">@param</span> {mixed} id of method call. Either a string, number or boolean or null. NULL has a special meaning for json-rpc
* <span class="attrib">@constructor</span>
*/</span>
<span class="reserved">function</span> jsonrpcmsg(meth, pars, id)
{
	<span class="reserved">this</span>.id = null;
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.params = []; <span class="comment">// somehow needed for making this weird subclassing work</span>
	<span class="comment">/** <span class="attrib">@private</span> **/</span>
	<span class="reserved">this</span>.content_type = <span class="literal">'application/json'</span>;

	<span class="reserved">if</span>(id !== undefined)
	{
		<span class="reserved">this</span>.id = id;
	}

	<span class="reserved">this</span>.init(meth, pars);
}

<span class="comment">// let jsonrpcresp inherit methods from xmlrpcresp</span>
jsonrpcmsg.<span class="reserved">prototype</span> = new xmlrpcmsg();

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
jsonrpcmsg.<span class="reserved">prototype</span>.parseResponse = <span class="reserved">function</span> (data, headers_processed, return_type)
{
	var headers = <span class="literal">''</span>;
	<span class="reserved">if</span> (headers_processed === undefined)
	{
		headers_processed = false;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (typeof(headers_processed) == <span class="literal">'string'</span>)
	{
		headers = headers_processed;
		headers_processed = true;
	}

	<span class="reserved">if</span> (return_type === undefined)
	{
		return_type = <span class="literal">'jsonrpcvals'</span>;
	}

	<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
	{
		xmlrpc_debug_log(<span class="literal">'&lt;PRE&gt;---GOT---\n'</span> + htmlentities(data) + <span class="literal">'\n---END---\n&lt;/PRE&gt;'</span>);
	}
	<span class="reserved">if</span> (data == <span class="literal">''</span>)
	{
		xmlrpc_error_log(<span class="literal">'XML-RPC: jsonrpcmsg::parseResponse: no response received from server.'</span>);
		var r = new jsonrpcresp(0, xmlrpcerr[<span class="literal">'no_data'</span>], xmlrpcstr[<span class="literal">'no_data'</span>]);
		<span class="reserved">return</span> r;
	}

	_xh = {headers: [], cookies: []};
	var raw_data = data;
	<span class="comment">// examining http headers: check first if given as second param to function</span>
	<span class="reserved">if</span> (headers != <span class="literal">''</span>)
	{
		var r = <span class="reserved">this</span>.parseResponseHeaders(headers, true);
	}
	<span class="comment">// else check if http headers given as part of complete html response</span>
	<span class="reserved">else</span> <span class="reserved">if</span> (data.slice(0, 4) == <span class="literal">'HTTP'</span>)
	{
		<span class="comment">// if it was so, remove them (or return an error response, if parsing fails)</span>
		var r = <span class="reserved">this</span>.ParseResponseHeaders(data, headers_processed);
		<span class="reserved">if</span> (typeof(r) !== <span class="literal">'string'</span>)
		{
			r.raw_data = data;
			<span class="reserved">return</span> r;
		}
		<span class="reserved">else</span>
		{
			data = r;
		}
	}

	<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
	{
		var start = data.indexOf(<span class="literal">'/* SERVER DEBUG INFO (BASE64 ENCODED):'</span>);
		<span class="reserved">if</span> (start != -1)
		{
			start += 39; <span class="comment">//new String('&lt;!-- SERVER DEBUG INFO (BASE64 ENCODED):').length();</span>
			var end = data.indexOf(<span class="literal">'*/'</span>, start);
			var comments = data.slice(start, end-1);
			xmlrpc_debug_log(<span class="literal">'&lt;PRE&gt;---SERVER DEBUG INFO (DECODED)---\n\t'</span>+htmlentities(base64_decode(comments).replace(/\n/g, <span class="literal">'\n\t'</span>))+<span class="literal">'\n---END---\n&lt;/PRE&gt;'</span>);
		}
	}

	<span class="comment">// be tolerant of extra whitespace in response body</span>
	data = data.replace(/^\s/, <span class="literal">''</span>).replace(/\s$/, <span class="literal">''</span>);

	<span class="comment">// be tolerant of junk after methodResponse (e.g. javascript ads automatically inserted by free hosts)</span>
	var pos = data.lastIndexOf(<span class="literal">'}'</span>);
	<span class="reserved">if</span> (pos &gt;= 0)
	{
		data = data.slice(0, pos+17);
	}

	<span class="comment">// if user wants back raw json, give it to him</span>
	<span class="reserved">if</span> (return_type == <span class="literal">'json'</span>)
	{
		var r = new jsonrpcresp(data, 0, <span class="literal">''</span>, <span class="literal">'json'</span>);
		r.hdrs = _xh[<span class="literal">'headers'</span>];
		r._cookies = _xh[<span class="literal">'cookies'</span>];
		r.raw_data = raw_data;
		<span class="reserved">return</span> r;
	}

	<span class="comment">// <span class="attrib">@todo</span> shall we try to check for non-unicode json received ???</span>

	<span class="reserved">if</span> (!jsonrpc_parse_resp(data, return_type==<span class="literal">'jsvals'</span>))
	{
		<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
		{
			<span class="comment">/// <span class="attrib">@todo</span> echo something for user?</span>
		}

		var r = new jsonrpcresp(0, xmlrpcerr[<span class="literal">'invalid_return'</span>],
					xmlrpcstr[<span class="literal">'invalid_return'</span>] + <span class="literal">' '</span> + _xh[<span class="literal">'isf_reason'</span>]);
	}
			<span class="comment">//elseif ($return_type == 'jsonrpcvals' &amp;&amp; !is_object($GLOBALS['_xh']['value']))</span>
			<span class="comment">//{</span>
				<span class="comment">// then something odd has happened</span>
				<span class="comment">// and it's time to generate a client side error</span>
				<span class="comment">// indicating something odd went on</span>
			<span class="comment">//	$r = &amp; new jsonrpcresp(0, $GLOBALS['xmlrpcerr']['invalid_return'],</span>
			<span class="comment">//		$GLOBALS['xmlrpcstr']['invalid_return']);</span>
			<span class="comment">//}</span>
	<span class="reserved">else</span>
	{
		var v = _xh[<span class="literal">'value'</span>];

		<span class="reserved">if</span> (<span class="reserved">this</span>.debug)
		{
			xmlrpc_debug_log(<span class="literal">"&lt;PRE&gt;---PARSED---\n"</span>);
			xmlrpc_debug_log(var_export(v));
			xmlrpc_debug_log(<span class="literal">"\n---END---&lt;/PRE&gt;"</span>);
		}

		<span class="reserved">if</span>(_xh[<span class="literal">'isf'</span>])
		{
			var r = new jsonrpcresp(0, v[<span class="literal">'faultCode'</span>], v[<span class="literal">'faultString'</span>]);
		}
		<span class="reserved">else</span>
		{
			var r = new jsonrpcresp(v, 0, <span class="literal">''</span>, return_type);
		}
		r.id = _xh[<span class="literal">'id'</span>];
	}

	r.hdrs = _xh[<span class="literal">'headers'</span>];
	r._cookies = _xh[<span class="literal">'cookies'</span>];
	r.raw_data = raw_data;
	<span class="reserved">return</span> r;
}

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
jsonrpcmsg.<span class="reserved">prototype</span>.createPayload = <span class="reserved">function</span> (charset_encoding)
{
	<span class="comment">/// @ todo: verify if all chars are allowed for method names or can</span>
	<span class="comment">/// we just skip the js encoding on it?</span>
	<span class="reserved">this</span>.payload = <span class="literal">'{\n"method": "'</span> + json_encode_entities(<span class="reserved">this</span>.methodname, <span class="literal">''</span>, charset_encoding) + <span class="literal">'",\n"params": [ '</span>;
	<span class="reserved">for</span>(var i = 0; i &lt; <span class="reserved">this</span>.params.length; ++i)
	{
		<span class="comment">// NB: we try to force serialization as json even though the object</span>
		<span class="comment">// param might be a plain xmlrpcval object.</span>
		<span class="comment">// This way we do not need to override addParam, aren't we lazy?</span>
		<span class="reserved">this</span>.payload += <span class="literal">'\n  '</span> + serialize_jsonrpcval(<span class="reserved">this</span>.params[i], charset_encoding) + <span class="literal">','</span>;
	}
	<span class="reserved">this</span>.payload = <span class="reserved">this</span>.payload.slice(0, -1) + <span class="literal">'\n],\n"id": '</span> + (<span class="reserved">this</span>.id == null ? <span class="literal">'null'</span> : <span class="reserved">this</span>.id) + <span class="literal">'\n}\n'</span>;
}

<span class="comment">/******************************************************************************/</span>
<span class="comment">/**
* <span class="attrib">@constructor</span>
*/</span>
<span class="reserved">function</span> jsonrpcresp(val, fcode, fstr, valtyp)
{
	<span class="reserved">this</span>.id = null;

	<span class="reserved">this</span>.init(val, fcode, fstr, valtyp);
}

<span class="comment">// let jsonrpcresp inherit methods, default values, from xmlrpcresp</span>
jsonrpcresp.<span class="reserved">prototype</span> = new xmlrpcresp();

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
jsonrpcresp.<span class="reserved">prototype</span>.serialize = <span class="reserved">function</span> (charset_encoding)
{
	<span class="reserved">this</span>.payload = serialize_jsonrpcresp(<span class="reserved">this</span>, <span class="reserved">this</span>.id, charset_encoding);
	<span class="reserved">return</span> <span class="reserved">this</span>.payload;
}

<span class="comment">/******************************************************************************/</span>
<span class="comment">/**
* Create a jsonrpcval object out of a plain javascript value
* <span class="attrib">@param</span> {mixed} val
* <span class="attrib">@param</span> {string} type Any valid json type name (lowercase). If null, 'string' is assumed
* <span class="attrib">@constructor</span>
*/</span>
<span class="reserved">function</span> jsonrpcval(val, type)
{
	<span class="reserved">this</span>.init(val, type);
}

<span class="comment">// let jsonrpcval inherit from xmlrpcval</span>
jsonrpcval.<span class="reserved">prototype</span> = new xmlrpcval();

<span class="comment">/**
* <span class="attrib">@private</span>
*/</span>
jsonrpcval.<span class="reserved">prototype</span>.serialize = <span class="reserved">function</span> (charset_encoding)
{
	<span class="reserved">return</span> serialize_jsonrpcval(<span class="reserved">this</span>, charset_encoding);
}

<span class="comment">/******************************************************************************/</span>

<span class="comment">/**
* Takes a json value in jsonrpcval object format
* and translates it into native javascript types.
* <span class="attrib">@public</span>
**/</span>
<span class="reserved">function</span> jsonrpc_decode(jsonrpc_val, options)
{
	switch(jsonrpc_val.kindOf())
	{
		case <span class="literal">'scalar'</span>:
			<span class="reserved">return</span> jsonrpc_val.scalarVal();
		case <span class="literal">'array'</span>:
			var size = jsonrpc_val.arraySize();
			var arr = [];
			<span class="reserved">for</span>(var i = 0; i &lt; size; ++i)
			{
				arr[arr.length] = jsonrpc_decode(jsonrpc_val.arrayMem(i), options);
			}
			<span class="reserved">return</span> arr;
		case <span class="literal">'struct'</span>:
			<span class="comment">// If user said so, try to rebuild js objects for specific struct vals.</span>
			<span class="comment">/// <span class="attrib">@todo</span> should we raise a warning for class not found?</span>
			<span class="comment">// shall we check for proper subclass of xmlrpcval instead of</span>
			<span class="comment">// presence of _php_class to detect what we can do?</span>
			<span class="reserved">if</span> ((options != undefined &amp;&amp; options[<span class="literal">'decode_js_objs'</span>]) &amp;&amp; jsonrpc_val._js_class != <span class="literal">''</span>)
				<span class="comment">//&amp;&amp; class_exists($xmlrpc_val-&gt;_php_class)) /// <span class="attrib">@todo</span> check if a class exists with given name</span>
			{
				var obj = new jsonrpc_val._js_class;
			}
			<span class="reserved">else</span>
			{
				var obj = {};
			}
			<span class="reserved">for</span>(var key in jsonrpc_val.me)
			{
				obj[key] = jsonrpc_decode(jsonrpc_val.me[key], options);
			}
			<span class="reserved">return</span> obj;
		case <span class="literal">'msg'</span>:
			var paramcount = jsonrpc_val.getNumParams();
			var arr = [];
			<span class="reserved">for</span>(var i = 0; i &lt; paramcount; ++i)
			{
				arr[arr.lenght] = jsonrpc_val(jsonrpc_val.getParam(i));
			}
			<span class="reserved">return</span> arr;
		}
}

<span class="comment">/**
* Takes native javascript types and encodes them into jsonrpc object format.
* It will not re-encode jsonrpcval objects.
* <span class="attrib">@public</span>
**/</span>
<span class="reserved">function</span> jsonrpc_encode(js_val, options)
{
	var type = typeof js_val;
	switch(type)
	{
		case <span class="literal">'string'</span>:
			<span class="comment">//if ((options != undefined &amp;&amp; options['auto_dates']) &amp;&amp; js_val.search(/^[0-9]{8}T[0-9]{2}:[0-9]{2}:[0-9]{2}$/) != -1)</span>
			<span class="comment">//	var xmlrpc_val = new xmlrpcval(js_val, 'dateTime.iso8601');</span>
			<span class="comment">//else</span>
				var jsonrpc_val = new jsonrpcval(js_val, <span class="literal">'string'</span>);
			break;
		case <span class="literal">'number'</span>:
			<span class="comment">/// <span class="attrib">@todo</span>...</span>
			var num = new Number(js_val);
			<span class="reserved">if</span> (num == parseInt(num))
			{
				var jsonrpc_val = new jsonrpcval(js_val, <span class="literal">'int'</span>);
			}
			<span class="reserved">else</span> <span class="comment">//if (num == parseFloat(num))</span>
			{
				var jsonrpc_val = new jsonrpcval(js_val, <span class="literal">'double'</span>);
			}
			<span class="comment">//else</span>
			<span class="comment">//{</span>
				<span class="comment">// ??? only NaN and Infinity can get here. Encode them as zero (double)...</span>
			<span class="comment">//	var xmlrpc_val = new xmlrpcval(0, 'double');</span>
			<span class="comment">//}</span>
			break;
		case <span class="literal">'boolean'</span>:
			var jsonrpc_val = new jsonrpcval(js_val, <span class="literal">'boolean'</span>);
			break;
		case <span class="literal">'object'</span>:
			<span class="comment">// we should be able to use js_val instanceof Null, but FF refuses it...</span>
			<span class="comment">// nb: check nulls first, since they have no attributes</span>
			<span class="reserved">if</span> (js_val === null)
			{
				<span class="comment">//if (options != undefined &amp;&amp; options['null_extension'])</span>
				<span class="comment">//{</span>
					var jsonrpc_val = new jsonrpcval(null, <span class="literal">'null'</span>);
				<span class="comment">//}</span>
				<span class="comment">//else</span>
				<span class="comment">//{</span>
				<span class="comment">//	var xmlrpc_val = new xmlrpcval();</span>
				<span class="comment">//}</span>
			}
			<span class="reserved">else</span>
			<span class="reserved">if</span> (js_val.toJsonRpcVal)
			{
				var jsonrpc_val = js_val.toJsonRpcVal();
			}
			<span class="reserved">else</span>
			<span class="reserved">if</span> (js_val instanceof Array)
			{
				var arr = [];
					<span class="reserved">for</span>(var i = 0; i &lt; js_val.length; ++i)
					{
						arr[arr.length] = jsonrpc_encode(js_val[i], options);
					}
					var jsonrpc_val = new jsonrpcval(arr, <span class="literal">'array'</span>);
			}
			<span class="reserved">else</span>
			<span class="comment">// xmlrpcval acquired capability to do this on its own, declaring toXmlRpcVal()</span>
			<span class="comment">//if (js_val instanceof xmlrpcval)</span>
			<span class="comment">//{</span>
			<span class="comment">//	var xmlrpc_val = js_val;</span>
			<span class="comment">//}</span>
			<span class="comment">//else</span>
			{
				<span class="comment">// generic js object. encode all members except functions</span>
				var arr = {};
				<span class="reserved">for</span>(var attr in js_val)
				{
					<span class="reserved">if</span> (typeof js_val[attr] != <span class="literal">'function'</span>)
					{
						arr[attr] = jsonrpc_encode(js_val[attr], options);
					}
				}
				var jsonrpc_val = new jsonrpcval(arr, <span class="literal">'struct'</span>);
				<span class="comment">/*if (in_array('encode_php_objs', options))
				{
					// let's save original class name into xmlrpcval:
					// might be useful later on...
					$xmlrpc_val._php_class = get_class($php_val);
				}*/</span>
			}
			break;
		<span class="comment">// match 'function', 'undefined', ...</span>
		default:
			<span class="comment">// it has to return an empty object in case</span>
			var jsonrpc_val = new jsonrpcval();
			break;
		}
		<span class="reserved">return</span> jsonrpc_val;
}

<span class="comment">/**
* Convert the json representation of a jsonrpc method call, jsonrpc method response
* or single json value into the appropriate object (deserialize)
* <span class="attrib">@param</span> {string} json_val
* <span class="attrib">@param</span> {object} options not used (yet)
* <span class="attrib">@type</span> false | jsonrpcresp | jsonrpcmsg | jsonrpcval
* <span class="attrib">@public</span>
*
* <span class="attrib">@bug</span> cannot tell a jsonrpc object from a reponse/request, if the object contains
*      the same members
**/</span>
<span class="reserved">function</span> jsonrpc_decode_json(json_val, options)
{

	<span class="comment">//if (typeof(options) == 'object')</span>
	<span class="comment">//{</span>
	<span class="comment">//	src_encoding = options['src_encoding'] != undefined  ? options['src_encoding'] : xmlrpc_defencoding;</span>
	<span class="comment">//	dest_encoding = options['dest_encoding'] != undefined ? options['dest_encoding'] : xmlrpc_internalencoding;</span>
	<span class="comment">//}</span>

	_xh = {};
	<span class="comment">//_xh['isf'] = 0;</span>
	<span class="comment">//if (!json_parse(json_val, false, src_encoding, dest_encoding))</span>
	<span class="reserved">if</span> (!json_parse_native(json_val))
	{
		xmlrpc_error_log(_xh[<span class="literal">'isf_reason'</span>]);
		<span class="reserved">return</span> false;
	}
	<span class="reserved">else</span>
	{
		<span class="reserved">if</span> (typeof(_xh[<span class="literal">'value'</span>]) == <span class="literal">'object'</span> )
		{
			<span class="reserved">if</span> (<span class="comment">/*_xh['value'].length == 3 &amp;&amp;*/</span> _xh[<span class="literal">'value'</span>][<span class="literal">'result'</span>] !== undefined
				&amp;&amp; _xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>] !== undefined &amp;&amp; _xh[<span class="literal">'value'</span>][<span class="literal">'id'</span>] !== undefined)
			{
				<span class="comment">// decoding a jsonrpc reponse. Check first for error case</span>
				<span class="reserved">if</span> (_xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>] != null)
				{
					<span class="reserved">if</span> (typeof(_xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>]) == <span class="literal">'object'</span> &amp;&amp; _xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>][<span class="literal">'faultCode'</span>] !== undefined
						&amp;&amp; _xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>][<span class="literal">'faultString'</span>] !== undefined)
					{
						<span class="reserved">if</span> (_xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>][<span class="literal">'faultCode'</span>] == 0)
						{
							<span class="comment">// FAULT returned, errno needs to reflect that</span>
							_xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>][<span class="literal">'faultCode'</span>] = -1;
						}
					}
					<span class="comment">// NB: what about jsonrpc servers that do NOT respect</span>
					<span class="comment">// the faultCode/faultString convention???</span>
					<span class="comment">// we force the error into a string. regardless of type...</span>
					<span class="reserved">else</span> <span class="comment">//if (is_string(_xh['value']))</span>
					{
						_xh[<span class="literal">'value'</span>] = {<span class="literal">'faultCode'</span>: -1, <span class="literal">'faultString'</span>: var_export(_xh[<span class="literal">'value'</span>][<span class="literal">'error'</span>])};
					}
					var r = new jsonrpcresp(0, _xh[<span class="literal">'value'</span>][<span class="literal">'faultCode'</span>], _xh[<span class="literal">'value'</span>][<span class="literal">'faultString'</span>]);
				}
				<span class="reserved">else</span>
				{
					var r = new jsonrpcresp(jsonrpc_encode(_xh[<span class="literal">'value'</span>][<span class="literal">'result'</span>]));
				}
				r.id = _xh[<span class="literal">'value'</span>][<span class="literal">'id'</span>];
				<span class="reserved">return</span> r;
			}
			<span class="reserved">else</span> <span class="reserved">if</span> (<span class="comment">/*_xh['value'].length == 3 &amp;&amp;*/</span> _xh[<span class="literal">'value'</span>][<span class="literal">'method'</span>] !== undefined
				&amp;&amp; _xh[<span class="literal">'value'</span>][<span class="literal">'params'</span>] !== undefined &amp;&amp; _xh[<span class="literal">'value'</span>][<span class="literal">'id'</span>] !== undefined)
			{
				var r = new jsonrpcmsg(_xh[<span class="literal">'value'</span>][<span class="literal">'method'</span>], null, _xh[<span class="literal">'value'</span>][<span class="literal">'id'</span>]);
				<span class="reserved">for</span> (var i = 0; i &lt; _xh[<span class="literal">'value'</span>][<span class="literal">'params'</span>].length; i++)
					r.addParam(jsonrpc_encode(_xh[<span class="literal">'value'</span>][<span class="literal">'params'</span>][i]));
				<span class="reserved">return</span> r;
			}
			<span class="comment">//else</span>
			<span class="comment">//	return new jsonrpcval(_xh['value'], 'struct');</span>
		}
		<span class="comment">//else</span>
		<span class="comment">// parsing ok, but not a response / request: it must be a plain jsonrpcval</span>
		<span class="reserved">return</span> jsonrpc_encode(_xh[<span class="literal">'value'</span>]);
	}
}

<span class="comment">/**
* Serialize a jsonrpcresp (or xmlrpcresp) as json.
* <span class="attrib">@private</span>
*/</span>
<span class="reserved">function</span> serialize_jsonrpcresp (resp, id, charset_encoding)
{
		var result = <span class="literal">'{\n"id": '</span> + (id == undefined ? <span class="literal">'null'</span> : id) + <span class="literal">', '</span>;
		<span class="reserved">if</span>(resp.errno)
		{
			<span class="comment">// let non-ASCII response messages be tolerated by clients</span>
			<span class="comment">// by encoding non ascii chars</span>
			result += <span class="literal">'"error": { "faultCode": '</span> + resp.errno + <span class="literal">', "faultString": "'</span> + json_encode_entities(resp.errstr, null, charset_encoding) + <span class="literal">'" }, "result": null'</span>;
		}
		<span class="reserved">else</span>
		{
			<span class="reserved">if</span>(typeof resp.val != <span class="literal">'object'</span> || !(resp.val instanceof xmlrpcval))
			{
				<span class="reserved">if</span>(typeof resp.val == <span class="literal">'string'</span> &amp;&amp; resp.valtyp == <span class="literal">'json'</span>)
				{
					result += <span class="literal">'"error": null, "result": '</span> + resp.val;
				}
				<span class="reserved">else</span>
				{
					<span class="comment">/// <span class="attrib">@todo</span> try to build something serializable?</span>
					<span class="comment">//die('cannot serialize jsonrpcresp objects whose content is native php values');</span>
				}
			}
			<span class="reserved">else</span>
			{
				result += <span class="literal">'"error": null, "result": '</span> +
					serialize_jsonrpcval(resp.val, charset_encoding);
			}
		}
		result += <span class="literal">'\n}'</span>;
		<span class="reserved">return</span> result;
}

<span class="comment">/**
* Serialize a jsonrpcval (or xmlrpcval) as json.
* <span class="attrib">@private</span>
*/</span>
<span class="reserved">function</span> serialize_jsonrpcval (value, charset_encoding)
{
	var rs = <span class="literal">''</span>;
	switch(value.mytype)
	{
		case 1:
			rs += <span class="literal">'"'</span> + json_encode_entities(value.me, null, charset_encoding) + <span class="literal">'"'</span>;
			break;
		case 4:
			<span class="reserved">if</span>(isFinite(value.me))
			{
				rs += value.me.toFixed(); <span class="comment">// as per Ecma-262, toFixed is better than toString...</span>
			}
			<span class="reserved">else</span>
			{
				rs += <span class="literal">'0'</span>;
			}
			break;
		case 5:
			<span class="comment">// add a .0 in case value is integer.</span>
			<span class="comment">// This helps us carrying around floats in js, and keep them separated from ints</span>
			<span class="reserved">if</span>(isFinite(value.me) &amp;&amp; value.me !== null)
			{
				rs += value.me.toString();
				var num = new Number(value.me);
				<span class="reserved">if</span>(num == parseInt(num))
				{
					rs += <span class="literal">'.0'</span>;
				}
			}
			<span class="reserved">else</span>
			{
				rs += <span class="literal">'0'</span>;
			}
			break;
		case 6:
			rs += (value.me ? <span class="literal">'true'</span> : <span class="literal">'false'</span>);
			break;
		case 7:
			rs += <span class="literal">'"'</span> + value.me + <span class="literal">'"'</span>; <span class="comment">/// <span class="attrib">@todo</span> add some date string validation ???</span>
			break;
		case 8:
			<span class="comment">// treat base 64 values as strings ???</span>
			rs += <span class="literal">'"'</span> + base64_encode(value.me) + <span class="literal">'"'</span>;
			break;
		case 9:
			rs += <span class="literal">"null"</span>;
			break;
		case 2:
			<span class="comment">// array</span>
			rs += <span class="literal">"["</span>;
			len = (value.me.length);
			<span class="reserved">if</span>(len)
			{
				<span class="reserved">for</span>(var i = 0; i &lt; len-1; ++i)
				{
					rs += serialize_jsonrpcval(value.me[i], charset_encoding);
					rs += <span class="literal">","</span>;
				}
				rs += serialize_jsonrpcval(value.me[i], charset_encoding);
			}
			rs += <span class="literal">"]"</span>;
			break;
		case 3:
			<span class="comment">// struct</span>
			<span class="comment">//if($value-&gt;_php_class)</span>
			<span class="comment">//{</span>
				<span class="comment">/// <span class="attrib">@todo</span> implement json-rpc extension for object serialization</span>
				<span class="comment">//$rs.='&lt;struct php_class="' . value._php_class . "\"&gt;\n";</span>
			<span class="comment">//}</span>
			<span class="comment">//else</span>
			<span class="comment">//{</span>
			<span class="comment">//}</span>
			<span class="reserved">for</span>(var val in value.me)
			{
				rs += <span class="literal">',"'</span> + json_encode_entities(val, null, charset_encoding) + <span class="literal">'":'</span>;
				rs += serialize_jsonrpcval(value.me[val], charset_encoding);
			}
			rs = <span class="literal">'{'</span> + rs.slice(1) + <span class="literal">'}'</span>;
			break;
	}
	<span class="reserved">return</span> rs;
}
</pre>
	<hr>



<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top"><em>
<b>js-xmlrpc</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<font size="-1">

</font>
<div class="jsdoc_ctime">Documentation generated by <a href="http://jsdoc.sourceforge.net/" target="_parent">JSDoc</a> on Tue Jun 26 14:36:04 2007</div>
</body>
</html>
